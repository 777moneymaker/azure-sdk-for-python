# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

from enum import Enum
from azure.core import CaseInsensitiveEnumMeta


class AllocationState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """Whether the Pool is resizing."""

    #: The Pool is not resizing. There are no changes to the number of Compute Nodes in the Pool in
    #: progress. A Pool enters this state when it is created and when no operations are being
    #: performed on the Pool to change the number of Compute Nodes.
    STEADY = "steady"
    #: The Pool is resizing; that is, Compute Nodes are being added to or removed from the Pool.
    RESIZING = "resizing"
    #: The Pool was resizing, but the user has requested that the resize be stopped, but the stop
    #: request has not yet been completed.
    STOPPING = "stopping"


class AutoUserScope(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The default value is pool. If the pool is running Windows a value of Task should be specified
    if stricter isolation between tasks is required. For example, if the task mutates the registry
    in a way which could impact other tasks, or if certificates have been specified on the pool
    which should not be accessible by normal tasks but should be accessible by StartTasks.
    """

    #: Specifies that the service should create a new user for the Task.
    TASK = "task"
    #: Specifies that the Task runs as the common auto user Account which is created on every Compute
    #: Node in a Pool.
    POOL = "pool"


class CachingType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The default value for caching is none. For information about the caching options see:
    https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
    """

    #: The caching mode for the disk is not enabled.
    NONE = "none"
    #: The caching mode for the disk is read only.
    READ_ONLY = "readonly"
    #: The caching mode for the disk is read and write.
    READ_WRITE = "readwrite"


class CertificateFormat(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The format of the Certificate data."""

    #: The Certificate is a PFX (PKCS#12) formatted Certificate or Certificate chain.
    PFX = "pfx"
    #: The Certificate is a base64-encoded X.509 Certificate.
    CER = "cer"


class CertificateState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The state of the Certificate."""

    #: The Certificate is available for use in Pools.
    ACTIVE = "active"
    #: The user has requested that the Certificate be deleted, but the delete operation has not yet
    #: completed. You may not reference the Certificate when creating or updating Pools.
    DELETING = "deleting"
    #: The user requested that the Certificate be deleted, but there are Pools that still have
    #: references to the Certificate, or it is still installed on one or more Nodes. (The latter can
    #: occur if the Certificate has been removed from the Pool, but the Compute Node has not yet
    #: restarted. Compute Nodes refresh their Certificates only when they restart.) You may use the
    #: cancel Certificate delete operation to cancel the delete, or the delete Certificate operation
    #: to retry the delete.
    DELETE_FAILED = "deletefailed"


class CertificateStoreLocation(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The default value is currentuser. This property is applicable only for Pools configured with
    Windows Compute Nodes (that is, created with cloudServiceConfiguration, or with
    virtualMachineConfiguration using a Windows Image reference). For Linux Compute Nodes, the
    Certificates are stored in a directory inside the Task working directory and an environment
    variable AZ_BATCH_CERTIFICATES_DIR is supplied to the Task to query for this location. For
    Certificates with visibility of 'remoteUser', a 'certs' directory is created in the user's home
    directory (e.g., /home/{user-name}/certs) and Certificates are placed in that directory.
    """

    #: Certificates should be installed to the CurrentUser Certificate store.
    CURRENT_USER = "currentuser"
    #: Certificates should be installed to the LocalMachine Certificate store.
    LOCAL_MACHINE = "localmachine"


class CertificateVisibility(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """CertificateVisibility."""

    #: The Certificate should be visible to the user account under which the StartTask is run. Note
    #: that if AutoUser Scope is Pool for both the StartTask and a Task, this certificate will be
    #: visible to the Task as well.
    START_TASK = "starttask"
    #: The Certificate should be visible to the user accounts under which Job Tasks are run.
    TASK = "task"
    #: The Certificate should be visible to the user accounts under which users remotely access the
    #: Compute Node.
    REMOTE_USER = "remoteuser"


class ComputeNodeDeallocationOption(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The default value is requeue."""

    #: Terminate running Task processes and requeue the Tasks. The Tasks will run again when a Compute
    #: Node is available. Remove Compute Nodes as soon as Tasks have been terminated.
    REQUEUE = "requeue"
    #: Terminate running Tasks. The Tasks will be completed with failureInfo indicating that they were
    #: terminated, and will not run again. Remove Compute Nodes as soon as Tasks have been terminated.
    TERMINATE = "terminate"
    #: Allow currently running Tasks to complete. Schedule no new Tasks while waiting. Remove Compute
    #: Nodes when all Tasks have completed.
    TASK_COMPLETION = "taskcompletion"
    #: Allow currently running Tasks to complete, then wait for all Task data retention periods to
    #: expire. Schedule no new Tasks while waiting. Remove Compute Nodes when all Task retention
    #: periods have expired.
    RETAINED_DATA = "retaineddata"


class ComputeNodeFillType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """If not specified, the default is spread."""

    #: Tasks should be assigned evenly across all Compute Nodes in the Pool.
    SPREAD = "spread"
    #: As many Tasks as possible (taskSlotsPerNode) should be assigned to each Compute Node in the
    #: Pool before any Tasks are assigned to the next Compute Node in the Pool.
    PACK = "pack"


class ComputeNodeRebootOption(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The default value is requeue."""

    #: Terminate running Task processes and requeue the Tasks. The Tasks will run again when a Compute
    #: Node is available. Restart the Compute Node as soon as Tasks have been terminated.
    REQUEUE = "requeue"
    #: Terminate running Tasks. The Tasks will be completed with failureInfo indicating that they were
    #: terminated, and will not run again. Restart the Compute Node as soon as Tasks have been
    #: terminated.
    TERMINATE = "terminate"
    #: Allow currently running Tasks to complete. Schedule no new Tasks while waiting. Restart the
    #: Compute Node when all Tasks have completed.
    TASK_COMPLETION = "taskcompletion"
    #: Allow currently running Tasks to complete, then wait for all Task data retention periods to
    #: expire. Schedule no new Tasks while waiting. Restart the Compute Node when all Task retention
    #: periods have expired.
    RETAINED_DATA = "retaineddata"


class ComputeNodeReimageOption(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The default value is requeue."""

    #: Terminate running Task processes and requeue the Tasks. The Tasks will run again when a Compute
    #: Node is available. Reimage the Compute Node as soon as Tasks have been terminated.
    REQUEUE = "requeue"
    #: Terminate running Tasks. The Tasks will be completed with failureInfo indicating that they were
    #: terminated, and will not run again. Reimage the Compute Node as soon as Tasks have been
    #: terminated.
    TERMINATE = "terminate"
    #: Allow currently running Tasks to complete. Schedule no new Tasks while waiting. Reimage the
    #: Compute Node when all Tasks have completed.
    TASK_COMPLETION = "taskcompletion"
    #: Allow currently running Tasks to complete, then wait for all Task data retention periods to
    #: expire. Schedule no new Tasks while waiting. Reimage the Compute Node when all Task retention
    #: periods have expired.
    RETAINED_DATA = "retaineddata"


class ComputeNodeState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The Spot/Low-priority Compute Node has been preempted. Tasks which were running on the Compute
    Node when it was preempted will be rescheduled when another Compute Node becomes available.
    """

    #: The Compute Node is not currently running a Task.
    IDLE = "idle"
    #: The Compute Node is rebooting.
    REBOOTING = "rebooting"
    #: The Compute Node is reimaging.
    REIMAGING = "reimaging"
    #: The Compute Node is running one or more Tasks (other than a StartTask).
    RUNNING = "running"
    #: The Compute Node cannot be used for Task execution due to errors.
    UNUSABLE = "unusable"
    #: The Batch service has obtained the underlying virtual machine from Azure Compute, but it has
    #: not yet started to join the Pool.
    CREATING = "creating"
    #: The Batch service is starting on the underlying virtual machine.
    STARTING = "starting"
    #: The StartTask has started running on the Compute Node, but waitForSuccess is set and the
    #: StartTask has not yet completed.
    WAITING_FOR_START_TASK = "waitingforstarttask"
    #: The StartTask has failed on the Compute Node (and exhausted all retries), and waitForSuccess is
    #: set. The Compute Node is not usable for running Tasks.
    START_TASK_FAILED = "starttaskfailed"
    #: The Batch service has lost contact with the Compute Node, and does not know its true state.
    UNKNOWN = "unknown"
    #: The Compute Node is leaving the Pool, either because the user explicitly removed it or because
    #: the Pool is resizing or autoscaling down.
    LEAVING_POOL = "leavingpool"
    #: The Compute Node is not currently running a Task, and scheduling of new Tasks to the Compute
    #: Node is disabled.
    OFFLINE = "offline"
    #: The Spot/Low-priority Compute Node has been preempted. Tasks which were running on the Compute
    #: Node when it was preempted will be rescheduled when another Compute Node becomes available.
    PREEMPTED = "preempted"


class ContainerWorkingDirectory(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The default is 'taskWorkingDirectory'."""

    #: Use the standard Batch service Task working directory, which will contain the Task Resource
    #: Files populated by Batch.
    TASK_WORKING_DIRECTORY = "taskWorkingDirectory"
    #: Use the working directory defined in the container Image. Beware that this directory will not
    #: contain the Resource Files downloaded by Batch.
    CONTAINER_IMAGE_DEFAULT = "containerImageDefault"


class DependencyAction(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """Possible values are 'satisfy' (allowing dependent tasks to progress) and 'block' (dependent
    tasks continue to wait). Batch does not yet support cancellation of dependent tasks.
    """

    #: Satisfy tasks waiting on this task; once all dependencies are satisfied, the task will be
    #: scheduled to run.
    SATISFY = "satisfy"
    #: Blocks tasks waiting on this task, preventing them from being scheduled.
    BLOCK = "block"


class DisableComputeNodeSchedulingOption(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The default value is requeue."""

    #: Terminate running Task processes and requeue the Tasks. The Tasks may run again on other
    #: Compute Nodes, or when Task scheduling is re-enabled on this Compute Node. Enter offline state
    #: as soon as Tasks have been terminated.
    REQUEUE = "requeue"
    #: Terminate running Tasks. The Tasks will be completed with failureInfo indicating that they were
    #: terminated, and will not run again. Enter offline state as soon as Tasks have been terminated.
    TERMINATE = "terminate"
    #: Allow currently running Tasks to complete. Schedule no new Tasks while waiting. Enter offline
    #: state when all Tasks have completed.
    TASK_COMPLETION = "taskcompletion"


class DisableJobOption(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """What to do with active Tasks associated with the Job."""

    #: Terminate running Tasks and requeue them. The Tasks will run again when the Job is enabled.
    REQUEUE = "requeue"
    #: Terminate running Tasks. The Tasks will be completed with failureInfo indicating that they were
    #: terminated, and will not run again.
    TERMINATE = "terminate"
    #: Allow currently running Tasks to complete.
    WAIT = "wait"


class DiskEncryptionTarget(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """A disk to encrypt."""

    #: The OS Disk on the compute node is encrypted.
    OS_DISK = "osdisk"
    #: The temporary disk on the compute node is encrypted. On Linux this encryption applies to other
    #: partitions (such as those on mounted data disks) when encryption occurs at boot time.
    TEMPORARY_DISK = "temporarydisk"


class DynamicVNetAssignmentScope(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The scope of dynamic vnet assignment."""

    #: No dynamic VNet assignment is enabled.
    NONE = "none"
    #: Dynamic VNet assignment is done per-job.
    JOB = "job"


class ElevationLevel(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The elevation level of the user."""

    #: The user is a standard user without elevated access.
    NON_ADMIN = "nonadmin"
    #: The user is a user with elevated access and operates with full Administrator permissions.
    ADMIN = "admin"


class ErrorCategory(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The category of the error."""

    #: The error is due to a user issue, such as misconfiguration.
    USER_ERROR = "usererror"
    #: The error is due to an internal server issue.
    SERVER_ERROR = "servererror"


class InboundEndpointProtocol(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The protocol of the endpoint."""

    #: Use TCP for the endpoint.
    TCP = "tcp"
    #: Use UDP for the endpoint.
    UDP = "udp"


class IPAddressProvisioningType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The provisioning type for Public IP Addresses for the Pool."""

    #: A public IP will be created and managed by Batch. There may be multiple public IPs depending on
    #: the size of the Pool.
    BATCH_MANAGED = "batchmanaged"
    #: Public IPs are provided by the user and will be used to provision the Compute Nodes.
    USER_MANAGED = "usermanaged"
    #: No public IP Address will be created.
    NO_PUBLIC_IP_ADDRESSES = "nopublicipaddresses"


class JobAction(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The default is none for exit code 0 and terminate for all other exit conditions. If the Job's
    onTaskFailed property is noaction, then specifying this property returns an error and the add
    Task request fails with an invalid property value error; if you are calling the REST API
    directly, the HTTP status code is 400 (Bad Request).
    """

    #: Take no action.
    NONE = "none"
    #: Disable the Job. This is equivalent to calling the disable Job API, with a disableTasks value
    #: of requeue.
    DISABLE = "disable"
    #: Terminate the Job. The terminateReason in the Job's executionInfo is set to "TaskFailed".
    TERMINATE = "terminate"


class JobPreparationTaskState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The current state of the Job Preparation Task on the Compute Node."""

    #: The Task is currently running (including retrying).
    RUNNING = "running"
    #: The Task has exited with exit code 0, or the Task has exhausted its retry limit, or the Batch
    #: service was unable to start the Task due to Task preparation errors (such as resource file
    #: download failures).
    COMPLETED = "completed"


class JobReleaseTaskState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The current state of the Job Release Task on the Compute Node."""

    #: The Task is currently running (including retrying).
    RUNNING = "running"
    #: The Task has exited with exit code 0, or the Task has exhausted its retry limit, or the Batch
    #: service was unable to start the Task due to Task preparation errors (such as resource file
    #: download failures).
    COMPLETED = "completed"


class JobScheduleState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The state of the Job Schedule."""

    #: The Job Schedule is active and will create Jobs as per its schedule.
    ACTIVE = "active"
    #: The Job Schedule has terminated, either by reaching its end time or by the user terminating it
    #: explicitly.
    COMPLETED = "completed"
    #: The user has disabled the Job Schedule. The scheduler will not initiate any new Jobs will on
    #: this schedule, but any existing active Job will continue to run.
    DISABLED = "disabled"
    #: The Job Schedule has no more work to do, or has been explicitly terminated by the user, but the
    #: termination operation is still in progress. The scheduler will not initiate any new Jobs for
    #: this Job Schedule, nor is any existing Job active.
    TERMINATING = "terminating"
    #: The user has requested that the Job Schedule be deleted, but the delete operation is still in
    #: progress. The scheduler will not initiate any new Jobs for this Job Schedule, and will delete
    #: any existing Jobs and Tasks under the Job Schedule, including any active Job. The Job Schedule
    #: will be deleted when all Jobs and Tasks under the Job Schedule have been deleted.
    DELETING = "deleting"


class JobState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The state of the Job."""

    #: The Job is available to have Tasks scheduled.
    ACTIVE = "active"
    #: A user has requested that the Job be disabled, but the disable operation is still in progress
    #: (for example, waiting for Tasks to terminate).
    DISABLING = "disabling"
    #: A user has disabled the Job. No Tasks are running, and no new Tasks will be scheduled.
    DISABLED = "disabled"
    #: A user has requested that the Job be enabled, but the enable operation is still in progress.
    ENABLING = "enabling"
    #: The Job is about to complete, either because a Job Manager Task has completed or because the
    #: user has terminated the Job, but the terminate operation is still in progress (for example,
    #: because Job Release Tasks are running).
    TERMINATING = "terminating"
    #: All Tasks have terminated, and the system will not accept any more Tasks or any further changes
    #: to the Job.
    COMPLETED = "completed"
    #: A user has requested that the Job be deleted, but the delete operation is still in progress
    #: (for example, because the system is still terminating running Tasks).
    DELETING = "deleting"


class LoginMode(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The default value for VirtualMachineConfiguration Pools is 'batch' and for
    CloudServiceConfiguration Pools is 'interactive'.
    """

    #: The LOGON32_LOGON_BATCH Win32 login mode. The batch login mode is recommended for long running
    #: parallel processes.
    BATCH = "batch"
    #: The LOGON32_LOGON_INTERACTIVE Win32 login mode. UAC is enabled on Windows
    #: VirtualMachineConfiguration Pools. If this option is used with an elevated user identity in a
    #: Windows VirtualMachineConfiguration Pool, the user session will not be elevated unless the
    #: application executed by the Task command line is configured to always require administrative
    #: privilege or to always require maximum privilege.
    INTERACTIVE = "interactive"


class NetworkSecurityGroupRuleAccess(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The action that should be taken for a specified IP address, subnet range or tag."""

    #: Allow access.
    ALLOW = "allow"
    #: Deny access.
    DENY = "deny"


class NodePlacementPolicyType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The default value is regional."""

    #: All nodes in the pool will be allocated in the same region.
    REGIONAL = "regional"
    #: Nodes in the pool will be spread across different availability zones with best effort
    #: balancing.
    ZONAL = "zonal"


class OnAllTasksComplete(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The action the Batch service should take when all Tasks in the Job are in the completed state."""

    #: Do nothing. The Job remains active unless terminated or disabled by some other means.
    NO_ACTION = "noaction"
    #: Terminate the Job. The Job's terminateReason is set to 'AllTasksComplete'.
    TERMINATE_JOB = "terminatejob"


class OnTaskFailure(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """A Task is considered to have failed if has a failureInfo. A failureInfo is set if the Task
    completes with a non-zero exit code after exhausting its retry count, or if there was an error
    starting the Task, for example due to a resource file download error. The default is noaction.
    """

    #: Do nothing. The Job remains active unless terminated or disabled by some other means.
    NO_ACTION = "noaction"
    #: Take the action associated with the Task exit condition in the Task's exitConditions
    #: collection. (This may still result in no action being taken, if that is what the Task
    #: specifies.)
    PERFORM_EXIT_OPTIONS_JOB_ACTION = "performexitoptionsjobaction"


class OSType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The type of operating system (e.g. Windows or Linux) of the Image."""

    #: The Linux operating system.
    LINUX = "linux"
    #: The Windows operating system.
    WINDOWS = "windows"


class OutputFileUploadCondition(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The conditions under which a Task output file or set of files should be uploaded."""

    #: Upload the file(s) only after the Task process exits with an exit code of 0.
    TASK_SUCCESS = "tasksuccess"
    #: Upload the file(s) only after the Task process exits with a nonzero exit code.
    TASK_FAILURE = "taskfailure"
    #: Upload the file(s) after the Task process exits, no matter what the exit code was.
    TASK_COMPLETION = "taskcompletion"


class PoolIdentityType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The list of user identities associated with the Batch pool. The user identity dictionary key
    references will be ARM resource ids in the form:
    '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
    """

    #: Batch pool has user assigned identities with it.
    USER_ASSIGNED = "UserAssigned"
    #: Batch pool has no identity associated with it. Setting ``None`` in update pool will remove
    #: existing identities.
    NONE = "None"


class PoolLifetimeOption(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The minimum lifetime of created auto Pools, and how multiple Jobs on a schedule are assigned to
    Pools.
    """

    #: The Pool exists for the lifetime of the Job Schedule. The Batch Service creates the Pool when
    #: it creates the first Job on the schedule. You may apply this option only to Job Schedules, not
    #: to Jobs.
    JOB_SCHEDULE = "jobschedule"
    #: The Pool exists for the lifetime of the Job to which it is dedicated. The Batch service creates
    #: the Pool when it creates the Job. If the 'job' option is applied to a Job Schedule, the Batch
    #: service creates a new auto Pool for every Job created on the schedule.
    JOB = "job"


class PoolState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The current state of the Pool."""

    #: The Pool is available to run Tasks subject to the availability of Compute Nodes.
    ACTIVE = "active"
    #: The user has requested that the Pool be deleted, but the delete operation has not yet
    #: completed.
    DELETING = "deleting"


class SchedulingState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """Whether the Compute Node is available for Task scheduling."""

    #: Tasks can be scheduled on the Compute Node.
    ENABLED = "enabled"
    #: No new Tasks will be scheduled on the Compute Node. Tasks already running on the Compute Node
    #: may still run to completion. All Compute Nodes start with scheduling enabled.
    DISABLED = "disabled"


class StartTaskState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The state of the StartTask on the Compute Node."""

    #: The StartTask is currently running.
    RUNNING = "running"
    #: The StartTask has exited with exit code 0, or the StartTask has failed and the retry limit has
    #: reached, or the StartTask process did not run due to Task preparation errors (such as resource
    #: file download failures).
    COMPLETED = "completed"


class StatusLevelTypes(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """Level code."""

    ERROR = "Error"
    INFO = "Info"
    WARNING = "Warning"


class StorageAccountType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The storage Account type for use in creating data disks."""

    #: The data disk should use standard locally redundant storage.
    STANDARD_LRS = "standard_lrs"
    #: The data disk should use premium locally redundant storage.
    PREMIUM_LRS = "premium_lrs"


class SubtaskState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The state of the subtask."""

    #: The Task has been assigned to a Compute Node, but is waiting for a required Job Preparation
    #: Task to complete on the Compute Node. If the Job Preparation Task succeeds, the Task will move
    #: to running. If the Job Preparation Task fails, the Task will return to active and will be
    #: eligible to be assigned to a different Compute Node.
    PREPARING = "preparing"
    #: The Task is running on a Compute Node. This includes task-level preparation such as downloading
    #: resource files or deploying Packages specified on the Task - it does not necessarily mean that
    #: the Task command line has started executing.
    RUNNING = "running"
    #: The Task is no longer eligible to run, usually because the Task has finished successfully, or
    #: the Task has finished unsuccessfully and has exhausted its retry limit. A Task is also marked
    #: as completed if an error occurred launching the Task, or when the Task has been terminated.
    COMPLETED = "completed"


class TaskAddStatus(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The status of the add Task request."""

    #: The Task was added successfully.
    SUCCESS = "success"
    #: The Task failed to add due to a client error and should not be retried without modifying the
    #: request as appropriate.
    CLIENT_ERROR = "clienterror"
    #: Task failed to add due to a server error and can be retried without modification.
    SERVER_ERROR = "servererror"


class TaskExecutionResult(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The result of Task execution."""

    #: The Task ran successfully.
    SUCCESS = "success"
    #: There was an error during processing of the Task. The failure may have occurred before the Task
    #: process was launched, while the Task process was executing, or after the Task process exited.
    FAILURE = "failure"


class TaskState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The state of the Task."""

    #: The Task is queued and able to run, but is not currently assigned to a Compute Node. A Task
    #: enters this state when it is created, when it is enabled after being disabled, or when it is
    #: awaiting a retry after a failed run.
    ACTIVE = "active"
    #: The Task has been assigned to a Compute Node, but is waiting for a required Job Preparation
    #: Task to complete on the Compute Node. If the Job Preparation Task succeeds, the Task will move
    #: to running. If the Job Preparation Task fails, the Task will return to active and will be
    #: eligible to be assigned to a different Compute Node.
    PREPARING = "preparing"
    #: The Task is running on a Compute Node. This includes task-level preparation such as downloading
    #: resource files or deploying Packages specified on the Task - it does not necessarily mean that
    #: the Task command line has started executing.
    RUNNING = "running"
    #: The Task is no longer eligible to run, usually because the Task has finished successfully, or
    #: the Task has finished unsuccessfully and has exhausted its retry limit. A Task is also marked
    #: as completed if an error occurred launching the Task, or when the Task has been terminated.
    COMPLETED = "completed"


class VerificationType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """Whether the Azure Batch service actively verifies that the Image is compatible with the
    associated Compute Node agent SKU.
    """

    #: The Image is guaranteed to be compatible with the associated Compute Node agent SKU and all
    #: Batch features have been confirmed to work as expected.
    VERIFIED = "verified"
    #: The associated Compute Node agent SKU should have binary compatibility with the Image, but
    #: specific functionality has not been verified.
    UNVERIFIED = "unverified"
