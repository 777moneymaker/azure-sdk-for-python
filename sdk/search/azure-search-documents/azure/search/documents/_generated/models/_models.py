# coding=utf-8
# pylint: disable=too-many-lines
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

from typing import Any, Dict, List, Literal, Mapping, Optional, TYPE_CHECKING, Union, overload

from .. import _model_base
from .._model_base import rest_discriminator, rest_field

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from .. import models as _models


class AutocompleteItem(_model_base.Model):
    """The result of Autocomplete requests.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar text: The completed term. Required.
    :vartype text: str
    :ivar query_plus_text: The query along with the completed term. Required.
    :vartype query_plus_text: str
    """

    text: str = rest_field(visibility=["read"])
    """The completed term. Required."""
    query_plus_text: str = rest_field(name="queryPlusText", visibility=["read"])
    """The query along with the completed term. Required."""


class AutocompleteRequest(_model_base.Model):
    """Parameters for fuzzy matching, and other autocomplete query behaviors.

    All required parameters must be populated in order to send to server.

    :ivar search_text: The search text on which to base autocomplete results. Required.
    :vartype search_text: str
    :ivar autocomplete_mode: Specifies the mode for Autocomplete. The default is 'oneTerm'. Use
     'twoTerms'
     to get shingles and 'oneTermWithContext' to use the current context while
     producing auto-completed terms. Known values are: "oneTerm", "twoTerms", and
     "oneTermWithContext".
    :vartype autocomplete_mode: str or ~azure.search.documents.models.AutocompleteMode
    :ivar filter: An OData expression that filters the documents used to produce completed terms
     for the Autocomplete result.
    :vartype filter: str
    :ivar use_fuzzy_matching: A value indicating whether to use fuzzy matching for the autocomplete
     query.
     Default is false. When set to true, the query will autocomplete terms even if
     there's a substituted or missing character in the search text. While this
     provides a better experience in some scenarios, it comes at a performance cost
     as fuzzy autocomplete queries are slower and consume more resources.
    :vartype use_fuzzy_matching: bool
    :ivar highlight_post_tag: A string tag that is appended to hit highlights. Must be set with
     highlightPreTag. If omitted, hit highlighting is disabled.
    :vartype highlight_post_tag: str
    :ivar highlight_pre_tag: A string tag that is prepended to hit highlights. Must be set with
     highlightPostTag. If omitted, hit highlighting is disabled.
    :vartype highlight_pre_tag: str
    :ivar minimum_coverage: A number between 0 and 100 indicating the percentage of the index that
     must be
     covered by an autocomplete query in order for the query to be reported as a
     success. This parameter can be useful for ensuring search availability even for
     services with only one replica. The default is 80.
    :vartype minimum_coverage: float
    :ivar search_fields: The comma-separated list of field names to consider when querying for
     auto-completed terms. Target fields must be included in the specified
     suggester.
    :vartype search_fields: str
    :ivar suggester_name: The name of the suggester as specified in the suggesters collection
     that's part
     of the index definition. Required.
    :vartype suggester_name: str
    :ivar top: The number of auto-completed terms to retrieve. This must be a value between 1
     and 100. The default is 5.
    :vartype top: int
    """

    search_text: str = rest_field(name="search")
    """The search text on which to base autocomplete results. Required."""
    autocomplete_mode: Optional[Union[str, "_models.AutocompleteMode"]] = rest_field(name="autocompleteMode")
    """Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms'
     to get shingles and 'oneTermWithContext' to use the current context while
     producing auto-completed terms. Known values are: \"oneTerm\", \"twoTerms\", and
     \"oneTermWithContext\"."""
    filter: Optional[str] = rest_field()
    """An OData expression that filters the documents used to produce completed terms
     for the Autocomplete result."""
    use_fuzzy_matching: Optional[bool] = rest_field(name="fuzzy")
    """A value indicating whether to use fuzzy matching for the autocomplete query.
     Default is false. When set to true, the query will autocomplete terms even if
     there's a substituted or missing character in the search text. While this
     provides a better experience in some scenarios, it comes at a performance cost
     as fuzzy autocomplete queries are slower and consume more resources."""
    highlight_post_tag: Optional[str] = rest_field(name="highlightPostTag")
    """A string tag that is appended to hit highlights. Must be set with
     highlightPreTag. If omitted, hit highlighting is disabled."""
    highlight_pre_tag: Optional[str] = rest_field(name="highlightPreTag")
    """A string tag that is prepended to hit highlights. Must be set with
     highlightPostTag. If omitted, hit highlighting is disabled."""
    minimum_coverage: Optional[float] = rest_field(name="minimumCoverage")
    """A number between 0 and 100 indicating the percentage of the index that must be
     covered by an autocomplete query in order for the query to be reported as a
     success. This parameter can be useful for ensuring search availability even for
     services with only one replica. The default is 80."""
    search_fields: Optional[str] = rest_field(name="searchFields")
    """The comma-separated list of field names to consider when querying for
     auto-completed terms. Target fields must be included in the specified
     suggester."""
    suggester_name: str = rest_field(name="suggesterName")
    """The name of the suggester as specified in the suggesters collection that's part
     of the index definition. Required."""
    top: Optional[int] = rest_field()
    """The number of auto-completed terms to retrieve. This must be a value between 1
     and 100. The default is 5."""

    @overload
    def __init__(
        self,
        *,
        search_text: str,
        suggester_name: str,
        autocomplete_mode: Optional[Union[str, "_models.AutocompleteMode"]] = None,
        filter: Optional[str] = None,  # pylint: disable=redefined-builtin
        use_fuzzy_matching: Optional[bool] = None,
        highlight_post_tag: Optional[str] = None,
        highlight_pre_tag: Optional[str] = None,
        minimum_coverage: Optional[float] = None,
        search_fields: Optional[str] = None,
        top: Optional[int] = None,
    ): ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:  # pylint: disable=useless-super-delegation
        super().__init__(*args, **kwargs)


class AutocompleteResult(_model_base.Model):
    """The result of Autocomplete query.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar coverage: A value indicating the percentage of the index that was considered by the
     autocomplete request, or null if minimumCoverage was not specified in the
     request.
    :vartype coverage: float
    :ivar results: The list of returned Autocompleted items. Required.
    :vartype results: list[~azure.search.documents.models.AutocompleteItem]
    """

    coverage: Optional[float] = rest_field(name="@search.coverage", visibility=["read"])
    """A value indicating the percentage of the index that was considered by the
     autocomplete request, or null if minimumCoverage was not specified in the
     request."""
    results: List["_models.AutocompleteItem"] = rest_field(name="value", visibility=["read"])
    """The list of returned Autocompleted items. Required."""


class FacetResult(_model_base.Model):
    """A single bucket of a facet query result. Reports the number of documents with a
    field value falling within a particular range or having a particular value or
    interval.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar count: The approximate count of documents falling within the bucket described by this
     facet.
    :vartype count: int
    """

    count: Optional[int] = rest_field(visibility=["read"])
    """The approximate count of documents falling within the bucket described by this
     facet."""


class IndexAction(_model_base.Model):
    """Represents an index action that operates on a document.

    :ivar action_type: The operation to perform on a document in an indexing batch. Known values
     are: "upload", "merge", "mergeOrUpload", and "delete".
    :vartype action_type: str or ~azure.search.documents.models.IndexActionType
    """

    action_type: Optional[Union[str, "_models.IndexActionType"]] = rest_field(name="@search.action")
    """The operation to perform on a document in an indexing batch. Known values are: \"upload\",
     \"merge\", \"mergeOrUpload\", and \"delete\"."""

    @overload
    def __init__(
        self,
        *,
        action_type: Optional[Union[str, "_models.IndexActionType"]] = None,
    ): ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:  # pylint: disable=useless-super-delegation
        super().__init__(*args, **kwargs)


class IndexBatch(_model_base.Model):
    """Contains a batch of document write actions to send to the index.

    All required parameters must be populated in order to send to server.

    :ivar actions: The actions in the batch. Required.
    :vartype actions: list[~azure.search.documents.models.IndexAction]
    """

    actions: List["_models.IndexAction"] = rest_field(name="value")
    """The actions in the batch. Required."""

    @overload
    def __init__(
        self,
        *,
        actions: List["_models.IndexAction"],
    ): ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:  # pylint: disable=useless-super-delegation
        super().__init__(*args, **kwargs)


class IndexDocumentsResult(_model_base.Model):
    """Response containing the status of operations for all documents in the indexing
    request.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar results: The list of status information for each document in the indexing request.
     Required.
    :vartype results: list[~azure.search.documents.models.IndexingResult]
    """

    results: List["_models.IndexingResult"] = rest_field(name="value", visibility=["read"])
    """The list of status information for each document in the indexing request. Required."""


class IndexingResult(_model_base.Model):
    """Status of an indexing operation for a single document.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar key: The key of a document that was in the indexing request. Required.
    :vartype key: str
    :ivar error_message: The error message explaining why the indexing operation failed for the
     document
     identified by the key; null if indexing succeeded.
    :vartype error_message: str
    :ivar succeeded: A value indicating whether the indexing operation succeeded for the document
     identified by the key. Required.
    :vartype succeeded: bool
    :ivar status_code: The status code of the indexing operation. Possible values include: 200 for
     a
     successful update or delete, 201 for successful document creation, 400 for a
     malformed input document, 404 for document not found, 409 for a version
     conflict, 422 when the index is temporarily unavailable, or 503 for when the
     service is too busy. Required.
    :vartype status_code: int
    """

    key: str = rest_field(visibility=["read"])
    """The key of a document that was in the indexing request. Required."""
    error_message: Optional[str] = rest_field(name="errorMessage", visibility=["read"])
    """The error message explaining why the indexing operation failed for the document
     identified by the key; null if indexing succeeded."""
    succeeded: bool = rest_field(name="status", visibility=["read"])
    """A value indicating whether the indexing operation succeeded for the document
     identified by the key. Required."""
    status_code: int = rest_field(name="statusCode", visibility=["read"])
    """The status code of the indexing operation. Possible values include: 200 for a
     successful update or delete, 201 for successful document creation, 400 for a
     malformed input document, 404 for document not found, 409 for a version
     conflict, 422 when the index is temporarily unavailable, or 503 for when the
     service is too busy. Required."""


class QueryAnswerResult(_model_base.Model):
    """An answer is a text passage extracted from the contents of the most relevant
    documents that matched the query. Answers are extracted from the top search
    results. Answer candidates are scored and the top answers are selected.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar score: The score value represents how relevant the answer is to the query relative to
     other answers returned for the query.
    :vartype score: float
    :ivar key: The key of the document the answer was extracted from.
    :vartype key: str
    :ivar text: The text passage extracted from the document contents as the answer.
    :vartype text: str
    :ivar highlights: Same text passage as in the Text property with highlighted text phrases most
     relevant to the query.
    :vartype highlights: str
    """

    score: Optional[float] = rest_field(visibility=["read"])
    """The score value represents how relevant the answer is to the query relative to
     other answers returned for the query."""
    key: Optional[str] = rest_field(visibility=["read"])
    """The key of the document the answer was extracted from."""
    text: Optional[str] = rest_field(visibility=["read"])
    """The text passage extracted from the document contents as the answer."""
    highlights: Optional[str] = rest_field(visibility=["read"])
    """Same text passage as in the Text property with highlighted text phrases most
     relevant to the query."""


class QueryCaptionResult(_model_base.Model):
    """Captions are the most representative passages from the document relatively to
    the search query. They are often used as document summary. Captions are only
    returned for queries of type ``semantic``.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    :ivar text: A representative text passage extracted from the document most relevant to the
     search query.
    :vartype text: str
    :ivar highlights: Same text passage as in the Text property with highlighted phrases most
     relevant to the query.
    :vartype highlights: str
    """

    text: Optional[str] = rest_field(visibility=["read"])
    """A representative text passage extracted from the document most relevant to the
     search query."""
    highlights: Optional[str] = rest_field(visibility=["read"])
    """Same text passage as in the Text property with highlighted phrases most
     relevant to the query."""


class SearchDocumentsResult(_model_base.Model):
    """Response containing search results from an index.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar count: The total count of results found by the search operation, or null if the count
     was not requested. If present, the count may be greater than the number of
     results in this response. This can happen if you use the $top or $skip
     parameters, or if the query can't return all the requested documents in a
     single response.
    :vartype count: int
    :ivar coverage: A value indicating the percentage of the index that was included in the query,
     or null if minimumCoverage was not specified in the request.
    :vartype coverage: float
    :ivar facets: The facet query results for the search operation, organized as a collection of
     buckets for each faceted field; null if the query did not include any facet
     expressions.
    :vartype facets: dict[str, list[~azure.search.documents.models.FacetResult]]
    :ivar answers: The answers query results for the search operation; null if the answers query
     parameter was not specified or set to 'none'.
    :vartype answers: list[~azure.search.documents.models.QueryAnswerResult]
    :ivar next_page_parameters: Continuation JSON payload returned when the query can't return all
     the
     requested results in a single response. You can use this JSON along with
     @odata.nextLink to formulate another POST Search request to get the next part
     of the search response.
    :vartype next_page_parameters: ~azure.search.documents.models.SearchRequest
    :ivar results: The sequence of results returned by the query. Required.
    :vartype results: list[~azure.search.documents.models.SearchResult]
    :ivar next_link: Continuation URL returned when the query can't return all the requested
     results
     in a single response. You can use this URL to formulate another GET or POST
     Search request to get the next part of the search response. Make sure to use
     the same verb (GET or POST) as the request that produced this response.
    :vartype next_link: str
    :ivar semantic_partial_response_reason: Reason that a partial response was returned for a
     semantic ranking request. Known values are: "maxWaitExceeded", "capacityOverloaded", and
     "transient".
    :vartype semantic_partial_response_reason: str or
     ~azure.search.documents.models.SemanticErrorReason
    :ivar semantic_partial_response_type: Type of partial response that was returned for a semantic
     ranking request. Known values are: "baseResults" and "rerankedResults".
    :vartype semantic_partial_response_type: str or
     ~azure.search.documents.models.SemanticSearchResultsType
    """

    count: Optional[int] = rest_field(name="@odata.count", visibility=["read"])
    """The total count of results found by the search operation, or null if the count
     was not requested. If present, the count may be greater than the number of
     results in this response. This can happen if you use the $top or $skip
     parameters, or if the query can't return all the requested documents in a
     single response."""
    coverage: Optional[float] = rest_field(name="@search.coverage", visibility=["read"])
    """A value indicating the percentage of the index that was included in the query,
     or null if minimumCoverage was not specified in the request."""
    facets: Optional[Dict[str, List["_models.FacetResult"]]] = rest_field(name="@search.facets", visibility=["read"])
    """The facet query results for the search operation, organized as a collection of
     buckets for each faceted field; null if the query did not include any facet
     expressions."""
    answers: Optional[List["_models.QueryAnswerResult"]] = rest_field(name="@search.answers", visibility=["read"])
    """The answers query results for the search operation; null if the answers query
     parameter was not specified or set to 'none'."""
    next_page_parameters: Optional["_models.SearchRequest"] = rest_field(
        name="@search.nextPageParameters", visibility=["read"]
    )
    """Continuation JSON payload returned when the query can't return all the
     requested results in a single response. You can use this JSON along with
     @odata.nextLink to formulate another POST Search request to get the next part
     of the search response."""
    results: List["_models.SearchResult"] = rest_field(name="value", visibility=["read"])
    """The sequence of results returned by the query. Required."""
    next_link: Optional[str] = rest_field(name="@odata.nextLink", visibility=["read"])
    """Continuation URL returned when the query can't return all the requested results
     in a single response. You can use this URL to formulate another GET or POST
     Search request to get the next part of the search response. Make sure to use
     the same verb (GET or POST) as the request that produced this response."""
    semantic_partial_response_reason: Optional[Union[str, "_models.SemanticErrorReason"]] = rest_field(
        name="@search.semanticPartialResponseReason", visibility=["read"]
    )
    """Reason that a partial response was returned for a semantic ranking request. Known values are:
     \"maxWaitExceeded\", \"capacityOverloaded\", and \"transient\"."""
    semantic_partial_response_type: Optional[Union[str, "_models.SemanticSearchResultsType"]] = rest_field(
        name="@search.semanticPartialResponseType", visibility=["read"]
    )
    """Type of partial response that was returned for a semantic ranking request. Known values are:
     \"baseResults\" and \"rerankedResults\"."""


class SearchRequest(_model_base.Model):  # pylint: disable=too-many-instance-attributes
    """Parameters for filtering, sorting, faceting, paging, and other search query
    behaviors.

    :ivar include_total_result_count: A value that specifies whether to fetch the total count of
     results. Default is
     false. Setting this value to true may have a performance impact. Note that the
     count returned is an approximation.
    :vartype include_total_result_count: bool
    :ivar facets: The list of facet expressions to apply to the search query. Each facet
     expression contains a field name, optionally followed by a comma-separated list
     of name:value pairs.
    :vartype facets: list[str]
    :ivar filter: The OData $filter expression to apply to the search query.
    :vartype filter: str
    :ivar highlight_fields: The comma-separated list of field names to use for hit highlights. Only
     searchable fields can be used for hit highlighting.
    :vartype highlight_fields: str
    :ivar highlight_post_tag: A string tag that is appended to hit highlights. Must be set with
     highlightPreTag. Default is &lt;/em&gt;.
    :vartype highlight_post_tag: str
    :ivar highlight_pre_tag: A string tag that is prepended to hit highlights. Must be set with
     highlightPostTag. Default is &lt;em&gt;.
    :vartype highlight_pre_tag: str
    :ivar minimum_coverage: A number between 0 and 100 indicating the percentage of the index that
     must be
     covered by a search query in order for the query to be reported as a success.
     This parameter can be useful for ensuring search availability even for services
     with only one replica. The default is 100.
    :vartype minimum_coverage: float
    :ivar order_by: The comma-separated list of OData $orderby expressions by which to sort the
     results. Each expression can be either a field name or a call to either the
     geo.distance() or the search.score() functions. Each expression can be followed
     by asc to indicate ascending, or desc to indicate descending. The default is
     ascending order. Ties will be broken by the match scores of documents. If no
     $orderby is specified, the default sort order is descending by document match
     score. There can be at most 32 $orderby clauses.
    :vartype order_by: str
    :ivar query_type: A value that specifies the syntax of the search query. The default is
     'simple'.
     Use 'full' if your query uses the Lucene query syntax. Known values are: "simple", "full", and
     "semantic".
    :vartype query_type: str or ~azure.search.documents.models.QueryType
    :ivar scoring_statistics: A value that specifies whether we want to calculate scoring
     statistics (such as
     document frequency) globally for more consistent scoring, or locally, for lower
     latency. The default is 'local'. Use 'global' to aggregate scoring statistics
     globally before scoring. Using global scoring statistics can increase latency
     of search queries. Known values are: "local" and "global".
    :vartype scoring_statistics: str or ~azure.search.documents.models.ScoringStatistics
    :ivar session_id: A value to be used to create a sticky session, which can help getting more
     consistent results. As long as the same sessionId is used, a best-effort
     attempt will be made to target the same replica set. Be wary that reusing the
     same sessionID values repeatedly can interfere with the load balancing of the
     requests across replicas and adversely affect the performance of the search
     service. The value used as sessionId cannot start with a '_' character.
    :vartype session_id: str
    :ivar scoring_parameters: The list of parameter values to be used in scoring functions (for
     example,
     referencePointParameter) using the format name-values. For example, if the
     scoring profile defines a function with a parameter called 'mylocation' the
     parameter string would be "mylocation--122.2,44.8" (without the quotes).
    :vartype scoring_parameters: list[str]
    :ivar scoring_profile: The name of a scoring profile to evaluate match scores for matching
     documents
     in order to sort the results.
    :vartype scoring_profile: str
    :ivar search_text: A full-text search query expression; Use "*" or omit this parameter to match
     all documents.
    :vartype search_text: str
    :ivar search_fields: The comma-separated list of field names to which to scope the full-text
     search.
     When using fielded search (fieldName:searchExpression) in a full Lucene query,
     the field names of each fielded search expression take precedence over any
     field names listed in this parameter.
    :vartype search_fields: str
    :ivar search_mode: A value that specifies whether any or all of the search terms must be
     matched
     in order to count the document as a match. Known values are: "any" and "all".
    :vartype search_mode: str or ~azure.search.documents.models.SearchMode
    :ivar select: The comma-separated list of fields to retrieve. If unspecified, all fields
     marked as retrievable in the schema are included.
    :vartype select: str
    :ivar skip: The number of search results to skip. This value cannot be greater than
     100,000. If you need to scan documents in sequence, but cannot use skip due to
     this limitation, consider using orderby on a totally-ordered key and filter
     with a range query instead.
    :vartype skip: int
    :ivar top: The number of search results to retrieve. This can be used in conjunction with
     $skip to implement client-side paging of search results. If results are
     truncated due to server-side paging, the response will include a continuation
     token that can be used to issue another Search request for the next page of
     results.
    :vartype top: int
    :ivar semantic_configuration: The name of a semantic configuration that will be used when
     processing
     documents for queries of type semantic.
    :vartype semantic_configuration: str
    :ivar semantic_error_handling: Allows the user to choose whether a semantic call should fail
     completely
     (default / current behavior), or to return partial results. Known values are: "partial" and
     "fail".
    :vartype semantic_error_handling: str or ~azure.search.documents.models.SemanticErrorMode
    :ivar semantic_max_wait_in_milliseconds: Allows the user to set an upper bound on the amount of
     time it takes for
     semantic enrichment to finish processing before the request fails.
    :vartype semantic_max_wait_in_milliseconds: int
    :ivar semantic_query: Allows setting a separate search query that will be solely used for
     semantic
     reranking, semantic captions and semantic answers. Is useful for scenarios
     where there is a need to use different queries between the base retrieval and
     ranking phase, and the L2 semantic phase.
    :vartype semantic_query: str
    :ivar answers: A value that specifies whether answers should be returned as part of the search
     response. Known values are: "none" and "extractive".
    :vartype answers: str or ~azure.search.documents.models.QueryAnswerType
    :ivar captions: A value that specifies whether captions should be returned as part of the
     search response. Known values are: "none" and "extractive".
    :vartype captions: str or ~azure.search.documents.models.QueryCaptionType
    :ivar vector_queries: The query parameters for vector and hybrid search queries.
    :vartype vector_queries: list[~azure.search.documents.models.VectorQuery]
    :ivar vector_filter_mode: Determines whether or not filters are applied before or after the
     vector search
     is performed. Default is 'preFilter' for new indexes. Known values are: "postFilter" and
     "preFilter".
    :vartype vector_filter_mode: str or ~azure.search.documents.models.VectorFilterMode
    """

    include_total_result_count: Optional[bool] = rest_field(name="count")
    """A value that specifies whether to fetch the total count of results. Default is
     false. Setting this value to true may have a performance impact. Note that the
     count returned is an approximation."""
    facets: Optional[List[str]] = rest_field()
    """The list of facet expressions to apply to the search query. Each facet
     expression contains a field name, optionally followed by a comma-separated list
     of name:value pairs."""
    filter: Optional[str] = rest_field()
    """The OData $filter expression to apply to the search query."""
    highlight_fields: Optional[str] = rest_field(name="highlight")
    """The comma-separated list of field names to use for hit highlights. Only
     searchable fields can be used for hit highlighting."""
    highlight_post_tag: Optional[str] = rest_field(name="highlightPostTag")
    """A string tag that is appended to hit highlights. Must be set with
     highlightPreTag. Default is &lt;/em&gt;."""
    highlight_pre_tag: Optional[str] = rest_field(name="highlightPreTag")
    """A string tag that is prepended to hit highlights. Must be set with
     highlightPostTag. Default is &lt;em&gt;."""
    minimum_coverage: Optional[float] = rest_field(name="minimumCoverage")
    """A number between 0 and 100 indicating the percentage of the index that must be
     covered by a search query in order for the query to be reported as a success.
     This parameter can be useful for ensuring search availability even for services
     with only one replica. The default is 100."""
    order_by: Optional[str] = rest_field(name="orderby")
    """The comma-separated list of OData $orderby expressions by which to sort the
     results. Each expression can be either a field name or a call to either the
     geo.distance() or the search.score() functions. Each expression can be followed
     by asc to indicate ascending, or desc to indicate descending. The default is
     ascending order. Ties will be broken by the match scores of documents. If no
     $orderby is specified, the default sort order is descending by document match
     score. There can be at most 32 $orderby clauses."""
    query_type: Optional[Union[str, "_models.QueryType"]] = rest_field(name="queryType")
    """A value that specifies the syntax of the search query. The default is 'simple'.
     Use 'full' if your query uses the Lucene query syntax. Known values are: \"simple\", \"full\",
     and \"semantic\"."""
    scoring_statistics: Optional[Union[str, "_models.ScoringStatistics"]] = rest_field(name="scoringStatistics")
    """A value that specifies whether we want to calculate scoring statistics (such as
     document frequency) globally for more consistent scoring, or locally, for lower
     latency. The default is 'local'. Use 'global' to aggregate scoring statistics
     globally before scoring. Using global scoring statistics can increase latency
     of search queries. Known values are: \"local\" and \"global\"."""
    session_id: Optional[str] = rest_field(name="sessionId")
    """A value to be used to create a sticky session, which can help getting more
     consistent results. As long as the same sessionId is used, a best-effort
     attempt will be made to target the same replica set. Be wary that reusing the
     same sessionID values repeatedly can interfere with the load balancing of the
     requests across replicas and adversely affect the performance of the search
     service. The value used as sessionId cannot start with a '_' character."""
    scoring_parameters: Optional[List[str]] = rest_field(name="scoringParameters")
    """The list of parameter values to be used in scoring functions (for example,
     referencePointParameter) using the format name-values. For example, if the
     scoring profile defines a function with a parameter called 'mylocation' the
     parameter string would be \"mylocation--122.2,44.8\" (without the quotes)."""
    scoring_profile: Optional[str] = rest_field(name="scoringProfile")
    """The name of a scoring profile to evaluate match scores for matching documents
     in order to sort the results."""
    search_text: Optional[str] = rest_field(name="search")
    """A full-text search query expression; Use \"*\" or omit this parameter to match
     all documents."""
    search_fields: Optional[str] = rest_field(name="searchFields")
    """The comma-separated list of field names to which to scope the full-text search.
     When using fielded search (fieldName:searchExpression) in a full Lucene query,
     the field names of each fielded search expression take precedence over any
     field names listed in this parameter."""
    search_mode: Optional[Union[str, "_models.SearchMode"]] = rest_field(name="searchMode")
    """A value that specifies whether any or all of the search terms must be matched
     in order to count the document as a match. Known values are: \"any\" and \"all\"."""
    select: Optional[str] = rest_field()
    """The comma-separated list of fields to retrieve. If unspecified, all fields
     marked as retrievable in the schema are included."""
    skip: Optional[int] = rest_field()
    """The number of search results to skip. This value cannot be greater than
     100,000. If you need to scan documents in sequence, but cannot use skip due to
     this limitation, consider using orderby on a totally-ordered key and filter
     with a range query instead."""
    top: Optional[int] = rest_field()
    """The number of search results to retrieve. This can be used in conjunction with
     $skip to implement client-side paging of search results. If results are
     truncated due to server-side paging, the response will include a continuation
     token that can be used to issue another Search request for the next page of
     results."""
    semantic_configuration: Optional[str] = rest_field(name="semanticConfiguration")
    """The name of a semantic configuration that will be used when processing
     documents for queries of type semantic."""
    semantic_error_handling: Optional[Union[str, "_models.SemanticErrorMode"]] = rest_field(
        name="semanticErrorHandling"
    )
    """Allows the user to choose whether a semantic call should fail completely
     (default / current behavior), or to return partial results. Known values are: \"partial\" and
     \"fail\"."""
    semantic_max_wait_in_milliseconds: Optional[int] = rest_field(name="semanticMaxWaitInMilliseconds")
    """Allows the user to set an upper bound on the amount of time it takes for
     semantic enrichment to finish processing before the request fails."""
    semantic_query: Optional[str] = rest_field(name="semanticQuery")
    """Allows setting a separate search query that will be solely used for semantic
     reranking, semantic captions and semantic answers. Is useful for scenarios
     where there is a need to use different queries between the base retrieval and
     ranking phase, and the L2 semantic phase."""
    answers: Optional[Union[str, "_models.QueryAnswerType"]] = rest_field()
    """A value that specifies whether answers should be returned as part of the search
     response. Known values are: \"none\" and \"extractive\"."""
    captions: Optional[Union[str, "_models.QueryCaptionType"]] = rest_field()
    """A value that specifies whether captions should be returned as part of the
     search response. Known values are: \"none\" and \"extractive\"."""
    vector_queries: Optional[List["_models.VectorQuery"]] = rest_field(name="vectorQueries")
    """The query parameters for vector and hybrid search queries."""
    vector_filter_mode: Optional[Union[str, "_models.VectorFilterMode"]] = rest_field(name="vectorFilterMode")
    """Determines whether or not filters are applied before or after the vector search
     is performed. Default is 'preFilter' for new indexes. Known values are: \"postFilter\" and
     \"preFilter\"."""

    @overload
    def __init__(
        self,
        *,
        include_total_result_count: Optional[bool] = None,
        facets: Optional[List[str]] = None,
        filter: Optional[str] = None,  # pylint: disable=redefined-builtin
        highlight_fields: Optional[str] = None,
        highlight_post_tag: Optional[str] = None,
        highlight_pre_tag: Optional[str] = None,
        minimum_coverage: Optional[float] = None,
        order_by: Optional[str] = None,
        query_type: Optional[Union[str, "_models.QueryType"]] = None,
        scoring_statistics: Optional[Union[str, "_models.ScoringStatistics"]] = None,
        session_id: Optional[str] = None,
        scoring_parameters: Optional[List[str]] = None,
        scoring_profile: Optional[str] = None,
        search_text: Optional[str] = None,
        search_fields: Optional[str] = None,
        search_mode: Optional[Union[str, "_models.SearchMode"]] = None,
        select: Optional[str] = None,
        skip: Optional[int] = None,
        top: Optional[int] = None,
        semantic_configuration: Optional[str] = None,
        semantic_error_handling: Optional[Union[str, "_models.SemanticErrorMode"]] = None,
        semantic_max_wait_in_milliseconds: Optional[int] = None,
        semantic_query: Optional[str] = None,
        answers: Optional[Union[str, "_models.QueryAnswerType"]] = None,
        captions: Optional[Union[str, "_models.QueryCaptionType"]] = None,
        vector_queries: Optional[List["_models.VectorQuery"]] = None,
        vector_filter_mode: Optional[Union[str, "_models.VectorFilterMode"]] = None,
    ): ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:  # pylint: disable=useless-super-delegation
        super().__init__(*args, **kwargs)


class SearchResult(_model_base.Model):
    """Contains a document found by a search query, plus associated metadata.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar score: The relevance score of the document compared to other documents returned by the
     query. Required.
    :vartype score: float
    :ivar reranker_score: The relevance score computed by the semantic ranker for the top search
     results.
     Search results are sorted by the RerankerScore first and then by the Score.
     RerankerScore is only returned for queries of type 'semantic'.
    :vartype reranker_score: float
    :ivar highlights: Text fragments from the document that indicate the matching search terms,
     organized by each applicable field; null if hit highlighting was not enabled
     for the query.
    :vartype highlights: dict[str, list[str]]
    :ivar captions: Captions are the most representative passages from the document relatively to
     the search query. They are often used as document summary. Captions are only
     returned for queries of type 'semantic'.
    :vartype captions: list[~azure.search.documents.models.QueryCaptionResult]
    """

    score: float = rest_field(name="@search.score", visibility=["read"])
    """The relevance score of the document compared to other documents returned by the
     query. Required."""
    reranker_score: Optional[float] = rest_field(name="@search.rerankerScore", visibility=["read"])
    """The relevance score computed by the semantic ranker for the top search results.
     Search results are sorted by the RerankerScore first and then by the Score.
     RerankerScore is only returned for queries of type 'semantic'."""
    highlights: Optional[Dict[str, List[str]]] = rest_field(name="@search.highlights", visibility=["read"])
    """Text fragments from the document that indicate the matching search terms,
     organized by each applicable field; null if hit highlighting was not enabled
     for the query."""
    captions: Optional[List["_models.QueryCaptionResult"]] = rest_field(name="@search.captions", visibility=["read"])
    """Captions are the most representative passages from the document relatively to
     the search query. They are often used as document summary. Captions are only
     returned for queries of type 'semantic'."""


class SuggestDocumentsResult(_model_base.Model):
    """Response containing suggestion query results from an index.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar results: The sequence of results returned by the query. Required.
    :vartype results: list[~azure.search.documents.models.SuggestResult]
    :ivar coverage: A value indicating the percentage of the index that was included in the query,
     or null if minimumCoverage was not set in the request.
    :vartype coverage: float
    """

    results: List["_models.SuggestResult"] = rest_field(name="value", visibility=["read"])
    """The sequence of results returned by the query. Required."""
    coverage: Optional[float] = rest_field(name="@search.coverage", visibility=["read"])
    """A value indicating the percentage of the index that was included in the query,
     or null if minimumCoverage was not set in the request."""


class SuggestRequest(_model_base.Model):  # pylint: disable=too-many-instance-attributes
    """Parameters for filtering, sorting, fuzzy matching, and other suggestions query
    behaviors.

    All required parameters must be populated in order to send to server.

    :ivar filter: An OData expression that filters the documents considered for suggestions.
    :vartype filter: str
    :ivar use_fuzzy_matching: A value indicating whether to use fuzzy matching for the suggestion
     query.
     Default is false. When set to true, the query will find suggestions even if
     there's a substituted or missing character in the search text. While this
     provides a better experience in some scenarios, it comes at a performance cost
     as fuzzy suggestion searches are slower and consume more resources.
    :vartype use_fuzzy_matching: bool
    :ivar highlight_post_tag: A string tag that is appended to hit highlights. Must be set with
     highlightPreTag. If omitted, hit highlighting of suggestions is disabled.
    :vartype highlight_post_tag: str
    :ivar highlight_pre_tag: A string tag that is prepended to hit highlights. Must be set with
     highlightPostTag. If omitted, hit highlighting of suggestions is disabled.
    :vartype highlight_pre_tag: str
    :ivar minimum_coverage: A number between 0 and 100 indicating the percentage of the index that
     must be
     covered by a suggestion query in order for the query to be reported as a
     success. This parameter can be useful for ensuring search availability even for
     services with only one replica. The default is 80.
    :vartype minimum_coverage: float
    :ivar order_by: The comma-separated list of OData $orderby expressions by which to sort the
     results. Each expression can be either a field name or a call to either the
     geo.distance() or the search.score() functions. Each expression can be followed
     by asc to indicate ascending, or desc to indicate descending. The default is
     ascending order. Ties will be broken by the match scores of documents. If no
     $orderby is specified, the default sort order is descending by document match
     score. There can be at most 32 $orderby clauses.
    :vartype order_by: str
    :ivar search_text: The search text to use to suggest documents. Must be at least 1 character,
     and
     no more than 100 characters. Required.
    :vartype search_text: str
    :ivar search_fields: The comma-separated list of field names to search for the specified search
     text. Target fields must be included in the specified suggester.
    :vartype search_fields: str
    :ivar select: The comma-separated list of fields to retrieve. If unspecified, only the key
     field will be included in the results.
    :vartype select: str
    :ivar suggester_name: The name of the suggester as specified in the suggesters collection
     that's part
     of the index definition. Required.
    :vartype suggester_name: str
    :ivar top: The number of suggestions to retrieve. This must be a value between 1 and 100.
     The default is 5.
    :vartype top: int
    """

    filter: Optional[str] = rest_field()
    """An OData expression that filters the documents considered for suggestions."""
    use_fuzzy_matching: Optional[bool] = rest_field(name="fuzzy")
    """A value indicating whether to use fuzzy matching for the suggestion query.
     Default is false. When set to true, the query will find suggestions even if
     there's a substituted or missing character in the search text. While this
     provides a better experience in some scenarios, it comes at a performance cost
     as fuzzy suggestion searches are slower and consume more resources."""
    highlight_post_tag: Optional[str] = rest_field(name="highlightPostTag")
    """A string tag that is appended to hit highlights. Must be set with
     highlightPreTag. If omitted, hit highlighting of suggestions is disabled."""
    highlight_pre_tag: Optional[str] = rest_field(name="highlightPreTag")
    """A string tag that is prepended to hit highlights. Must be set with
     highlightPostTag. If omitted, hit highlighting of suggestions is disabled."""
    minimum_coverage: Optional[float] = rest_field(name="minimumCoverage")
    """A number between 0 and 100 indicating the percentage of the index that must be
     covered by a suggestion query in order for the query to be reported as a
     success. This parameter can be useful for ensuring search availability even for
     services with only one replica. The default is 80."""
    order_by: Optional[str] = rest_field(name="orderby")
    """The comma-separated list of OData $orderby expressions by which to sort the
     results. Each expression can be either a field name or a call to either the
     geo.distance() or the search.score() functions. Each expression can be followed
     by asc to indicate ascending, or desc to indicate descending. The default is
     ascending order. Ties will be broken by the match scores of documents. If no
     $orderby is specified, the default sort order is descending by document match
     score. There can be at most 32 $orderby clauses."""
    search_text: str = rest_field(name="search")
    """The search text to use to suggest documents. Must be at least 1 character, and
     no more than 100 characters. Required."""
    search_fields: Optional[str] = rest_field(name="searchFields")
    """The comma-separated list of field names to search for the specified search
     text. Target fields must be included in the specified suggester."""
    select: Optional[str] = rest_field()
    """The comma-separated list of fields to retrieve. If unspecified, only the key
     field will be included in the results."""
    suggester_name: str = rest_field(name="suggesterName")
    """The name of the suggester as specified in the suggesters collection that's part
     of the index definition. Required."""
    top: Optional[int] = rest_field()
    """The number of suggestions to retrieve. This must be a value between 1 and 100.
     The default is 5."""

    @overload
    def __init__(
        self,
        *,
        search_text: str,
        suggester_name: str,
        filter: Optional[str] = None,  # pylint: disable=redefined-builtin
        use_fuzzy_matching: Optional[bool] = None,
        highlight_post_tag: Optional[str] = None,
        highlight_pre_tag: Optional[str] = None,
        minimum_coverage: Optional[float] = None,
        order_by: Optional[str] = None,
        search_fields: Optional[str] = None,
        select: Optional[str] = None,
        top: Optional[int] = None,
    ): ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:  # pylint: disable=useless-super-delegation
        super().__init__(*args, **kwargs)


class SuggestResult(_model_base.Model):
    """A result containing a document found by a suggestion query, plus associated
    metadata.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar text: The text of the suggestion result. Required.
    :vartype text: str
    """

    text: str = rest_field(name="@search.text", visibility=["read"])
    """The text of the suggestion result. Required."""


class VectorQuery(_model_base.Model):
    """The query parameters for vector and hybrid search queries.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    VectorizableTextQuery, VectorizedQuery

    All required parameters must be populated in order to send to server.

    :ivar kind: Required. Default value is None.
    :vartype kind: str
    :ivar k: Number of nearest neighbors to return as top hits.
    :vartype k: int
    :ivar fields: Vector Fields of type Collection(Edm.Single) to be included in the vector
     searched.
    :vartype fields: str
    :ivar exhaustive: When true, triggers an exhaustive k-nearest neighbor search across all
     vectors
     within the vector index. Useful for scenarios where exact matches are critical,
     such as determining ground truth values.
    :vartype exhaustive: bool
    :ivar oversampling: Oversampling factor. Minimum value is 1. It overrides the
     'defaultOversampling'
     parameter configured in the index definition. It can be set only when
     'rerankWithOriginalVectors' is true. This parameter is only permitted when a
     compression method is used on the underlying vector field.
    :vartype oversampling: float
    :ivar weight: Relative weight of the vector query when compared to other vector query and/or
     the text query within the same search request. This value is used when
     combining the results of multiple ranking lists produced by the different
     vector queries and/or the results retrieved through the text query. The higher
     the weight, the higher the documents that matched that query will be in the
     final ranking. Default is 1.0 and the value needs to be a positive number
     larger than zero.
    :vartype weight: float
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    kind: str = rest_discriminator(name="kind")
    """Required. Default value is None."""
    k: Optional[int] = rest_field()
    """Number of nearest neighbors to return as top hits."""
    fields: Optional[str] = rest_field()
    """Vector Fields of type Collection(Edm.Single) to be included in the vector
     searched."""
    exhaustive: Optional[bool] = rest_field()
    """When true, triggers an exhaustive k-nearest neighbor search across all vectors
     within the vector index. Useful for scenarios where exact matches are critical,
     such as determining ground truth values."""
    oversampling: Optional[float] = rest_field()
    """Oversampling factor. Minimum value is 1. It overrides the 'defaultOversampling'
     parameter configured in the index definition. It can be set only when
     'rerankWithOriginalVectors' is true. This parameter is only permitted when a
     compression method is used on the underlying vector field."""
    weight: Optional[float] = rest_field()
    """Relative weight of the vector query when compared to other vector query and/or
     the text query within the same search request. This value is used when
     combining the results of multiple ranking lists produced by the different
     vector queries and/or the results retrieved through the text query. The higher
     the weight, the higher the documents that matched that query will be in the
     final ranking. Default is 1.0 and the value needs to be a positive number
     larger than zero."""

    @overload
    def __init__(
        self,
        *,
        kind: str,
        k: Optional[int] = None,
        fields: Optional[str] = None,
        exhaustive: Optional[bool] = None,
        oversampling: Optional[float] = None,
        weight: Optional[float] = None,
    ): ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:  # pylint: disable=useless-super-delegation
        super().__init__(*args, **kwargs)


class VectorizableTextQuery(VectorQuery, discriminator="text"):
    """The query parameters to use for vector search when a text value that needs to
    be vectorized is provided.

    All required parameters must be populated in order to send to server.

    :ivar k: Number of nearest neighbors to return as top hits.
    :vartype k: int
    :ivar fields: Vector Fields of type Collection(Edm.Single) to be included in the vector
     searched.
    :vartype fields: str
    :ivar exhaustive: When true, triggers an exhaustive k-nearest neighbor search across all
     vectors
     within the vector index. Useful for scenarios where exact matches are critical,
     such as determining ground truth values.
    :vartype exhaustive: bool
    :ivar oversampling: Oversampling factor. Minimum value is 1. It overrides the
     'defaultOversampling'
     parameter configured in the index definition. It can be set only when
     'rerankWithOriginalVectors' is true. This parameter is only permitted when a
     compression method is used on the underlying vector field.
    :vartype oversampling: float
    :ivar weight: Relative weight of the vector query when compared to other vector query and/or
     the text query within the same search request. This value is used when
     combining the results of multiple ranking lists produced by the different
     vector queries and/or the results retrieved through the text query. The higher
     the weight, the higher the documents that matched that query will be in the
     final ranking. Default is 1.0 and the value needs to be a positive number
     larger than zero.
    :vartype weight: float
    :ivar text: The text to be vectorized to perform a vector search query. Required.
    :vartype text: str
    :ivar kind: The kind of vector query being performed. Required. Default value is "text".
    :vartype kind: str
    """

    text: str = rest_field()
    """The text to be vectorized to perform a vector search query. Required."""
    kind: Literal["text"] = rest_discriminator(name="kind")  # type: ignore
    """The kind of vector query being performed. Required. Default value is \"text\"."""

    @overload
    def __init__(
        self,
        *,
        text: str,
        k: Optional[int] = None,
        fields: Optional[str] = None,
        exhaustive: Optional[bool] = None,
        oversampling: Optional[float] = None,
        weight: Optional[float] = None,
    ): ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:  # pylint: disable=useless-super-delegation
        super().__init__(*args, kind="text", **kwargs)


class VectorizedQuery(VectorQuery, discriminator="vector"):
    """The query parameters to use for vector search when a raw vector value is
    provided.

    All required parameters must be populated in order to send to server.

    :ivar k: Number of nearest neighbors to return as top hits.
    :vartype k: int
    :ivar fields: Vector Fields of type Collection(Edm.Single) to be included in the vector
     searched.
    :vartype fields: str
    :ivar exhaustive: When true, triggers an exhaustive k-nearest neighbor search across all
     vectors
     within the vector index. Useful for scenarios where exact matches are critical,
     such as determining ground truth values.
    :vartype exhaustive: bool
    :ivar oversampling: Oversampling factor. Minimum value is 1. It overrides the
     'defaultOversampling'
     parameter configured in the index definition. It can be set only when
     'rerankWithOriginalVectors' is true. This parameter is only permitted when a
     compression method is used on the underlying vector field.
    :vartype oversampling: float
    :ivar weight: Relative weight of the vector query when compared to other vector query and/or
     the text query within the same search request. This value is used when
     combining the results of multiple ranking lists produced by the different
     vector queries and/or the results retrieved through the text query. The higher
     the weight, the higher the documents that matched that query will be in the
     final ranking. Default is 1.0 and the value needs to be a positive number
     larger than zero.
    :vartype weight: float
    :ivar vector: The vector representation of a search query. Required.
    :vartype vector: list[float]
    :ivar kind: The kind of vector query being performed. Required. Default value is "vector".
    :vartype kind: str
    """

    vector: List[float] = rest_field()
    """The vector representation of a search query. Required."""
    kind: Literal["vector"] = rest_discriminator(name="kind")  # type: ignore
    """The kind of vector query being performed. Required. Default value is \"vector\"."""

    @overload
    def __init__(
        self,
        *,
        vector: List[float],
        k: Optional[int] = None,
        fields: Optional[str] = None,
        exhaustive: Optional[bool] = None,
        oversampling: Optional[float] = None,
        weight: Optional[float] = None,
    ): ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:  # pylint: disable=useless-super-delegation
        super().__init__(*args, kind="vector", **kwargs)
