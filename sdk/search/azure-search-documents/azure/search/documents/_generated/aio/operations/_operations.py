# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
import sys
from typing import Any, AsyncIterable, Callable, Dict, IO, List, Literal, Optional, Type, TypeVar, Union, overload
import urllib.parse

from azure.core import MatchConditions
from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceModifiedError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._model_base import SdkJSONEncoder, _deserialize
from ...operations._operations import (
    build_data_sources_operations_create_or_update_request,
    build_data_sources_operations_create_request,
    build_data_sources_operations_delete_request,
    build_data_sources_operations_get_request,
    build_data_sources_operations_list_request,
    build_documents_operations_autocomplete_get_request,
    build_documents_operations_autocomplete_post_request,
    build_documents_operations_count_request,
    build_documents_operations_get_request,
    build_documents_operations_index_request,
    build_documents_operations_search_get_request,
    build_documents_operations_search_post_request,
    build_documents_operations_suggest_get_request,
    build_documents_operations_suggest_post_request,
    build_indexers_operations_create_or_update_request,
    build_indexers_operations_create_request,
    build_indexers_operations_delete_request,
    build_indexers_operations_get_request,
    build_indexers_operations_get_status_request,
    build_indexers_operations_list_request,
    build_indexers_operations_reset_request,
    build_indexers_operations_run_request,
    build_indexes_operations_analyze_request,
    build_indexes_operations_create_or_update_request,
    build_indexes_operations_create_request,
    build_indexes_operations_delete_request,
    build_indexes_operations_get_request,
    build_indexes_operations_get_statistics_request,
    build_indexes_operations_list_request,
    build_search_get_service_statistics_request,
    build_skillsets_operations_create_or_update_request,
    build_skillsets_operations_create_request,
    build_skillsets_operations_delete_request,
    build_skillsets_operations_get_request,
    build_skillsets_operations_list_request,
    build_synonym_maps_operations_create_or_update_request,
    build_synonym_maps_operations_create_request,
    build_synonym_maps_operations_delete_request,
    build_synonym_maps_operations_get_request,
    build_synonym_maps_operations_list_request,
)
from .._vendor import SearchClientMixinABC

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class DataSourcesOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.search.documents.aio.SearchClient`'s
        :attr:`data_sources_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create_or_update(
        self,
        data_source_name: str,
        data_source: _models.SearchIndexerDataSource,
        *,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource or updates a datasource if it already exists.

        :param data_source_name: The name of the datasource. Required.
        :type data_source_name: str
        :param data_source: The definition of the datasource to create or update. Required.
        :type data_source: ~azure.search.documents.models.SearchIndexerDataSource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # JSON input template you can fill out and use as your body input.
                data_source = {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        data_source_name: str,
        data_source: JSON,
        *,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource or updates a datasource if it already exists.

        :param data_source_name: The name of the datasource. Required.
        :type data_source_name: str
        :param data_source: The definition of the datasource to create or update. Required.
        :type data_source: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        data_source_name: str,
        data_source: IO[bytes],
        *,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource or updates a datasource if it already exists.

        :param data_source_name: The name of the datasource. Required.
        :type data_source_name: str
        :param data_source: The definition of the datasource to create or update. Required.
        :type data_source: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        data_source_name: str,
        data_source: Union[_models.SearchIndexerDataSource, JSON, IO[bytes]],
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource or updates a datasource if it already exists.

        :param data_source_name: The name of the datasource. Required.
        :type data_source_name: str
        :param data_source: The definition of the datasource to create or update. Is one of the
         following types: SearchIndexerDataSource, JSON, IO[bytes] Required.
        :type data_source: ~azure.search.documents.models.SearchIndexerDataSource or JSON or IO[bytes]
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # JSON input template you can fill out and use as your body input.
                data_source = {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        prefer: Literal["return=representation"] = kwargs.pop("prefer")
        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndexerDataSource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(data_source, (IOBase, bytes)):
            _content = data_source
        else:
            _content = json.dumps(data_source, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_data_sources_operations_create_or_update_request(
            data_source_name=data_source_name,
            etag=etag,
            match_condition=match_condition,
            prefer=prefer,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexerDataSource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        data_source_name: str,
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a datasource.

        :param data_source_name: The name of the datasource. Required.
        :type data_source_name: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_data_sources_operations_delete_request(
            data_source_name=data_source_name,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get(self, data_source_name: str, **kwargs: Any) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Retrieves a datasource definition.

        :param data_source_name: The name of the datasource. Required.
        :type data_source_name: str
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchIndexerDataSource] = kwargs.pop("cls", None)

        _request = build_data_sources_operations_get_request(
            data_source_name=data_source_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexerDataSource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list(self, *, _select: Optional[str] = None, **kwargs: Any) -> _models.ListDataSourcesResult:
        # pylint: disable=line-too-long
        """Lists all datasources available for a search service.

        :keyword _select: Selects which top-level properties to retrieve.
         Specified as a comma-separated list of JSON property names,
         or '*' for all properties. The default is all properties. Default value is None.
        :paramtype _select: str
        :return: ListDataSourcesResult. The ListDataSourcesResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.ListDataSourcesResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "container": {
                                "name": "str",  # The name of the table or view (for
                                  Azure SQL data source) or collection (for CosmosDB data source) that
                                  will be indexed. Required.
                                "query": "str"  # Optional. A query that is applied
                                  to this data container. The syntax and meaning of this parameter is
                                  datasource-specific. Not supported by Azure SQL datasources.
                            },
                            "credentials": {
                                "connectionString": "str"  # Optional. The connection
                                  string for the datasource. Set to ``<unchanged>`` (with brackets) if
                                  you don't want the connection string updated. Set to ``<redacted>``
                                  if you want to remove the connection string value from the
                                  datasource.
                            },
                            "name": "str",  # The name of the datasource. Required.
                            "type": "str",  # The type of the datasource. Required. Known
                              values are: "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql",
                              and "adlsgen2".
                            "@odata.etag": "str",  # Optional. The ETag of the data
                              source.
                            "dataChangeDetectionPolicy": data_change_detection_policy,
                            "dataDeletionDetectionPolicy":
                              data_deletion_detection_policy,
                            "description": "str",  # Optional. The description of the
                              datasource.
                            "encryptionKey": {
                                "keyVaultKeyName": "str",  # The name of your Azure
                                  Key Vault key to be used to encrypt your data at rest. Required.
                                "keyVaultKeyVersion": "str",  # The version of your
                                  Azure Key Vault key to be used to encrypt your data at rest.
                                  Required.
                                "keyVaultUri": "str",  # The URI of your Azure Key
                                  Vault, also referred to as DNS name, that contains the key to be used
                                  to encrypt your data at rest. An example URI might be
                                  ``https://my-keyvault-name.vault.azure.net``. Required.
                                "accessCredentials": {
                                    "applicationId": "str",  # An AAD Application
                                      ID that was granted the required access permissions to the Azure
                                      Key Vault that is to be used when encrypting your data at rest.
                                      The Application ID should not be confused with the Object ID for
                                      your AAD Application. Required.
                                    "applicationSecret": "str"  # Optional. The
                                      authentication key of the specified AAD application.
                                }
                            }
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListDataSourcesResult] = kwargs.pop("cls", None)

        _request = build_data_sources_operations_list_request(
            _select=_select,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ListDataSourcesResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self, data_source: _models.SearchIndexerDataSource, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource.

        :param data_source: The definition of the datasource to create. Required.
        :type data_source: ~azure.search.documents.models.SearchIndexerDataSource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # JSON input template you can fill out and use as your body input.
                data_source = {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create(
        self, data_source: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource.

        :param data_source: The definition of the datasource to create. Required.
        :type data_source: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create(
        self, data_source: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource.

        :param data_source: The definition of the datasource to create. Required.
        :type data_source: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @distributed_trace_async
    async def create(
        self, data_source: Union[_models.SearchIndexerDataSource, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource.

        :param data_source: The definition of the datasource to create. Is one of the following types:
         SearchIndexerDataSource, JSON, IO[bytes] Required.
        :type data_source: ~azure.search.documents.models.SearchIndexerDataSource or JSON or IO[bytes]
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # JSON input template you can fill out and use as your body input.
                data_source = {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndexerDataSource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(data_source, (IOBase, bytes)):
            _content = data_source
        else:
            _content = json.dumps(data_source, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_data_sources_operations_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexerDataSource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class IndexersOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.search.documents.aio.SearchClient`'s
        :attr:`indexers_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def reset(self, indexer_name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Resets the change tracking state associated with an indexer.

        :param indexer_name: The name of the indexer. Required.
        :type indexer_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_indexers_operations_reset_request(
            indexer_name=indexer_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def run(self, indexer_name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Runs an indexer on-demand.

        :param indexer_name: The name of the indexer. Required.
        :type indexer_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_indexers_operations_run_request(
            indexer_name=indexer_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def create_or_update(
        self,
        indexer_name: str,
        indexer: _models.SearchIndexer,
        *,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer or updates an indexer if it already exists.

        :param indexer_name: The name of the indexer. Required.
        :type indexer_name: str
        :param indexer: The definition of the indexer to create or update. Required.
        :type indexer: ~azure.search.documents.models.SearchIndexer
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                indexer = {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @overload
    async def create_or_update(
        self,
        indexer_name: str,
        indexer: JSON,
        *,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer or updates an indexer if it already exists.

        :param indexer_name: The name of the indexer. Required.
        :type indexer_name: str
        :param indexer: The definition of the indexer to create or update. Required.
        :type indexer: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @overload
    async def create_or_update(
        self,
        indexer_name: str,
        indexer: IO[bytes],
        *,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer or updates an indexer if it already exists.

        :param indexer_name: The name of the indexer. Required.
        :type indexer_name: str
        :param indexer: The definition of the indexer to create or update. Required.
        :type indexer: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        indexer_name: str,
        indexer: Union[_models.SearchIndexer, JSON, IO[bytes]],
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer or updates an indexer if it already exists.

        :param indexer_name: The name of the indexer. Required.
        :type indexer_name: str
        :param indexer: The definition of the indexer to create or update. Is one of the following
         types: SearchIndexer, JSON, IO[bytes] Required.
        :type indexer: ~azure.search.documents.models.SearchIndexer or JSON or IO[bytes]
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                indexer = {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        prefer: Literal["return=representation"] = kwargs.pop("prefer")
        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndexer] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(indexer, (IOBase, bytes)):
            _content = indexer
        else:
            _content = json.dumps(indexer, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_indexers_operations_create_or_update_request(
            indexer_name=indexer_name,
            etag=etag,
            match_condition=match_condition,
            prefer=prefer,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexer, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        indexer_name: str,
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Deletes an indexer.

        :param indexer_name: The name of the indexer. Required.
        :type indexer_name: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_indexers_operations_delete_request(
            indexer_name=indexer_name,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get(self, indexer_name: str, **kwargs: Any) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Retrieves an indexer definition.

        :param indexer_name: The name of the indexer. Required.
        :type indexer_name: str
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchIndexer] = kwargs.pop("cls", None)

        _request = build_indexers_operations_get_request(
            indexer_name=indexer_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexer, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list(self, *, _select: Optional[str] = None, **kwargs: Any) -> _models.ListIndexersResult:
        # pylint: disable=line-too-long
        """Lists all indexers available for a search service.

        :keyword _select: Selects which top-level properties to retrieve.
         Specified as a comma-separated list of JSON property names,
         or '*' for all properties. The default is all properties. Default value is None.
        :paramtype _select: str
        :return: ListIndexersResult. The ListIndexersResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.ListIndexersResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "dataSourceName": "str",  # The name of the datasource from
                              which this indexer reads data. Required.
                            "name": "str",  # The name of the indexer. Required.
                            "targetIndexName": "str",  # The name of the index to which
                              this indexer writes data. Required.
                            "@odata.etag": "str",  # Optional. The ETag of the indexer.
                            "description": "str",  # Optional. The description of the
                              indexer.
                            "disabled": bool,  # Optional. A value indicating whether the
                              indexer is disabled. Default is false.
                            "encryptionKey": {
                                "keyVaultKeyName": "str",  # The name of your Azure
                                  Key Vault key to be used to encrypt your data at rest. Required.
                                "keyVaultKeyVersion": "str",  # The version of your
                                  Azure Key Vault key to be used to encrypt your data at rest.
                                  Required.
                                "keyVaultUri": "str",  # The URI of your Azure Key
                                  Vault, also referred to as DNS name, that contains the key to be used
                                  to encrypt your data at rest. An example URI might be
                                  ``https://my-keyvault-name.vault.azure.net``. Required.
                                "accessCredentials": {
                                    "applicationId": "str",  # An AAD Application
                                      ID that was granted the required access permissions to the Azure
                                      Key Vault that is to be used when encrypting your data at rest.
                                      The Application ID should not be confused with the Object ID for
                                      your AAD Application. Required.
                                    "applicationSecret": "str"  # Optional. The
                                      authentication key of the specified AAD application.
                                }
                            },
                            "fieldMappings": [
                                {
                                    "sourceFieldName": "str",  # The name of the
                                      field in the data source. Required.
                                    "mappingFunction": {
                                        "name": "str",  # The name of the
                                          field mapping function. Required.
                                        "parameters": {
                                            "str": {}  # Optional. A
                                              dictionary of parameter name/value pairs to pass to the
                                              function. Each value must be of a primitive type.
                                        }
                                    },
                                    "targetFieldName": "str"  # Optional. The
                                      name of the target field in the index. Same as the source field
                                      name by default.
                                }
                            ],
                            "outputFieldMappings": [
                                {
                                    "sourceFieldName": "str",  # The name of the
                                      field in the data source. Required.
                                    "mappingFunction": {
                                        "name": "str",  # The name of the
                                          field mapping function. Required.
                                        "parameters": {
                                            "str": {}  # Optional. A
                                              dictionary of parameter name/value pairs to pass to the
                                              function. Each value must be of a primitive type.
                                        }
                                    },
                                    "targetFieldName": "str"  # Optional. The
                                      name of the target field in the index. Same as the source field
                                      name by default.
                                }
                            ],
                            "parameters": {
                                "batchSize": 0,  # Optional. The number of items that
                                  are read from the data source and indexed as a single batch in order
                                  to improve performance. The default depends on the data source type.
                                "configuration": {
                                    "allowSkillsetToReadFileData": bool,  #
                                      Optional. If true, will create a path //document//file_data that
                                      is an object representing the original file data downloaded from
                                      your blob data source. This allows you to pass the original file
                                      data to a custom skill for processing within the enrichment
                                      pipeline, or to the Document Extraction skill.
                                    "dataToExtract": "str",  # Optional.
                                      Specifies the data to extract from Azure blob storage and tells
                                      the indexer which data to extract from image content when
                                      "imageAction" is set to a value other than "none".  This applies
                                      to embedded image content in a .PDF or other application, or
                                      image files such as .jpg and .png, in Azure blobs. Known values
                                      are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                                    "delimitedTextDelimiter": "str",  # Optional.
                                      For CSV blobs, specifies the end-of-line single-character
                                      delimiter for CSV files where each line starts a new document
                                      (for example, "|").
                                    "delimitedTextHeaders": "str",  # Optional.
                                      For CSV blobs, specifies a comma-delimited list of column
                                      headers, useful for mapping source fields to destination fields
                                      in an index.
                                    "documentRoot": "str",  # Optional. For JSON
                                      arrays, given a structured or semi-structured document, you can
                                      specify a path to the array using this property.
                                    "excludedFileNameExtensions": "str",  #
                                      Optional. Comma-delimited list of filename extensions to ignore
                                      when processing from Azure blob storage.  For example, you could
                                      exclude ".png, .mp4" to skip over those files during indexing.
                                    "executionEnvironment": "str",  # Optional.
                                      Specifies the environment in which the indexer should execute.
                                      Known values are: "standard" and "private".
                                    "failOnUnprocessableDocument": bool,  #
                                      Optional. For Azure blobs, set to false if you want to continue
                                      indexing if a document fails indexing.
                                    "failOnUnsupportedContentType": bool,  #
                                      Optional. For Azure blobs, set to false if you want to continue
                                      indexing when an unsupported content type is encountered, and you
                                      don't know all the content types (file extensions) in advance.
                                    "firstLineContainsHeaders": bool,  #
                                      Optional. For CSV blobs, indicates that the first (non-blank)
                                      line of each blob contains headers.
                                    "imageAction": "str",  # Optional. Determines
                                      how to process embedded images and image files in Azure blob
                                      storage.  Setting the "imageAction" configuration to any value
                                      other than "none" requires that a skillset also be attached to
                                      that indexer. Known values are: "none",
                                      "generateNormalizedImages", and "generateNormalizedImagePerPage".
                "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                                      Optional. For Azure blobs, set this property to true to still
                                      index storage metadata for blob content that is too large to
                                      process. Oversized blobs are treated as errors by default. For
                                      limits on blob size, see
                                      https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                                    "indexedFileNameExtensions": "str",  #
                                      Optional. Comma-delimited list of filename extensions to select
                                      when processing from Azure blob storage.  For example, you could
                                      focus indexing on specific application files ".docx, .pptx, .msg"
                                      to specifically include those file types.
                                    "parsingMode": "str",  # Optional. Represents
                                      the parsing mode for indexing from an Azure blob data source.
                                      Known values are: "default", "text", "delimitedText", "json",
                                      "jsonArray", and "jsonLines".
                                    "pdfTextRotationAlgorithm": "str",  #
                                      Optional. Determines algorithm for text extraction from PDF files
                                      in Azure blob storage. Known values are: "none" and
                                      "detectAngles".
                                    "queryTimeout": "str"  # Optional. Increases
                                      the timeout beyond the 5-minute default for Azure SQL database
                                      data sources, specified in the format "hh:mm:ss".
                                },
                                "maxFailedItems": 0,  # Optional. The maximum number
                                  of items that can fail indexing for indexer execution to still be
                                  considered successful. -1 means no limit. Default is 0.
                                "maxFailedItemsPerBatch": 0  # Optional. The maximum
                                  number of items in a single batch that can fail indexing for the
                                  batch to still be considered successful. -1 means no limit. Default
                                  is 0.
                            },
                            "schedule": {
                                "interval": "1 day, 0:00:00",  # The interval of time
                                  between indexer executions. Required.
                                "startTime": "2020-02-20 00:00:00"  # Optional. The
                                  time when an indexer should start running.
                            },
                            "skillsetName": "str"  # Optional. The name of the skillset
                              executing with this indexer.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListIndexersResult] = kwargs.pop("cls", None)

        _request = build_indexers_operations_list_request(
            _select=_select,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ListIndexersResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self, indexer: _models.SearchIndexer, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer.

        :param indexer: The definition of the indexer to create. Required.
        :type indexer: ~azure.search.documents.models.SearchIndexer
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                indexer = {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @overload
    async def create(
        self, indexer: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer.

        :param indexer: The definition of the indexer to create. Required.
        :type indexer: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @overload
    async def create(
        self, indexer: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer.

        :param indexer: The definition of the indexer to create. Required.
        :type indexer: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @distributed_trace_async
    async def create(
        self, indexer: Union[_models.SearchIndexer, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SearchIndexer:
        # pylint: disable=line-too-long
        """Creates a new indexer.

        :param indexer: The definition of the indexer to create. Is one of the following types:
         SearchIndexer, JSON, IO[bytes] Required.
        :type indexer: ~azure.search.documents.models.SearchIndexer or JSON or IO[bytes]
        :return: SearchIndexer. The SearchIndexer is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexer
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                indexer = {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": bool,  # Optional. A value indicating whether the indexer is
                      disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": bool,  # Optional. If true,
                              will create a path //document//file_data that is an object representing
                              the original file data downloaded from your blob data source. This allows
                              you to pass the original file data to a custom skill for processing
                              within the enrichment pipeline, or to the Document Extraction skill.
                            "dataToExtract": "str",  # Optional. Specifies the data to
                              extract from Azure blob storage and tells the indexer which data to
                              extract from image content when "imageAction" is set to a value other
                              than "none".  This applies to embedded image content in a .PDF or other
                              application, or image files such as .jpg and .png, in Azure blobs. Known
                              values are: "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to ignore when processing
                              from Azure blob storage.  For example, you could exclude ".png, .mp4" to
                              skip over those files during indexing.
                            "executionEnvironment": "str",  # Optional. Specifies the
                              environment in which the indexer should execute. Known values are:
                              "standard" and "private".
                            "failOnUnprocessableDocument": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing if a document fails
                              indexing.
                            "failOnUnsupportedContentType": bool,  # Optional. For Azure
                              blobs, set to false if you want to continue indexing when an unsupported
                              content type is encountered, and you don't know all the content types
                              (file extensions) in advance.
                            "firstLineContainsHeaders": bool,  # Optional. For CSV blobs,
                              indicates that the first (non-blank) line of each blob contains headers.
                            "imageAction": "str",  # Optional. Determines how to process
                              embedded images and image files in Azure blob storage.  Setting the
                              "imageAction" configuration to any value other than "none" requires that
                              a skillset also be attached to that indexer. Known values are: "none",
                              "generateNormalizedImages", and "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": bool,  #
                              Optional. For Azure blobs, set this property to true to still index
                              storage metadata for blob content that is too large to process. Oversized
                              blobs are treated as errors by default. For limits on blob size, see
                              https://learn.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "str",  # Optional.
                              Comma-delimited list of filename extensions to select when processing
                              from Azure blob storage.  For example, you could focus indexing on
                              specific application files ".docx, .pptx, .msg" to specifically include
                              those file types.
                            "parsingMode": "str",  # Optional. Represents the parsing
                              mode for indexing from an Azure blob data source. Known values are:
                              "default", "text", "delimitedText", "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "str",  # Optional. Determines
                              algorithm for text extraction from PDF files in Azure blob storage. Known
                              values are: "none" and "detectAngles".
                            "queryTimeout": "str"  # Optional. Increases the timeout
                              beyond the 5-minute default for Azure SQL database data sources,
                              specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. The maximum number of items that
                          can fail indexing for indexer execution to still be considered successful. -1
                          means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. The maximum number of items
                          in a single batch that can fail indexing for the batch to still be considered
                          successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndexer] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(indexer, (IOBase, bytes)):
            _content = indexer
        else:
            _content = json.dumps(indexer, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_indexers_operations_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexer, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_status(self, indexer_name: str, **kwargs: Any) -> _models.SearchIndexerStatus:
        # pylint: disable=line-too-long
        """Returns the current status and execution history of an indexer.

        :param indexer_name: The name of the indexer. Required.
        :type indexer_name: str
        :return: SearchIndexerStatus. The SearchIndexerStatus is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerStatus
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "executionHistory": [
                        {
                            "errors": [
                                {
                                    "errorMessage": "str",  # The message
                                      describing the error that occurred while processing the item.
                                      Required.
                                    "statusCode": 0,  # The status code
                                      indicating why the indexing operation failed. Possible values
                                      include: 400 for a malformed input document, 404 for document not
                                      found, 409 for a version conflict, 422 when the index is
                                      temporarily unavailable, or 503 for when the service is too busy.
                                      Required.
                                    "details": "str",  # Optional. Additional,
                                      verbose details about the error to assist in debugging the
                                      indexer. This may not be always available.
                                    "documentationLink": "str",  # Optional. A
                                      link to a troubleshooting guide for these classes of errors. This
                                      may not be always available.
                                    "key": "str",  # Optional. The key of the
                                      item for which indexing failed.
                                    "name": "str"  # Optional. The name of the
                                      source at which the error originated. For example, this could
                                      refer to a particular skill in the attached skillset. This may
                                      not be always available.
                                }
                            ],
                            "itemsFailed": 0,  # The number of items that failed to be
                              indexed during this indexer execution. Required.
                            "itemsProcessed": 0,  # The number of items that were
                              processed during this indexer execution. This includes both successfully
                              processed items and items where indexing was attempted but failed.
                              Required.
                            "status": "str",  # The outcome of this indexer execution.
                              Required. Known values are: "transientFailure", "success", "inProgress",
                              and "reset".
                            "warnings": [
                                {
                                    "message": "str",  # The message describing
                                      the warning that occurred while processing the item. Required.
                                    "details": "str",  # Optional. Additional,
                                      verbose details about the warning to assist in debugging the
                                      indexer. This may not be always available.
                                    "documentationLink": "str",  # Optional. A
                                      link to a troubleshooting guide for these classes of warnings.
                                      This may not be always available.
                                    "key": "str",  # Optional. The key of the
                                      item which generated a warning.
                                    "name": "str"  # Optional. The name of the
                                      source at which the warning originated. For example, this could
                                      refer to a particular skill in the attached skillset. This may
                                      not be always available.
                                }
                            ],
                            "endTime": "2020-02-20 00:00:00",  # Optional. The end time
                              of this indexer execution, if the execution has already completed.
                            "errorMessage": "str",  # Optional. The error message
                              indicating the top-level error, if any.
                            "finalTrackingState": "str",  # Optional. Change tracking
                              state with which an indexer execution finished.
                            "initialTrackingState": "str",  # Optional. Change tracking
                              state with which an indexer execution started.
                            "startTime": "2020-02-20 00:00:00"  # Optional. The start
                              time of this indexer execution.
                        }
                    ],
                    "limits": {
                        "maxDocumentContentCharactersToExtract": 0,  # Optional. The maximum
                          number of characters that will be extracted from a document picked up for
                          indexing.
                        "maxDocumentExtractionSize": 0,  # Optional. The maximum size of a
                          document, in bytes, which will be considered valid for indexing.
                        "maxRunTime": "1 day, 0:00:00"  # Optional. The maximum duration that
                          the indexer is permitted to run for one execution.
                    },
                    "status": "str",  # Overall indexer status. Required. Known values are:
                      "unknown", "error", and "running".
                    "lastResult": {
                        "errors": [
                            {
                                "errorMessage": "str",  # The message describing the
                                  error that occurred while processing the item. Required.
                                "statusCode": 0,  # The status code indicating why
                                  the indexing operation failed. Possible values include: 400 for a
                                  malformed input document, 404 for document not found, 409 for a
                                  version conflict, 422 when the index is temporarily unavailable, or
                                  503 for when the service is too busy. Required.
                                "details": "str",  # Optional. Additional, verbose
                                  details about the error to assist in debugging the indexer. This may
                                  not be always available.
                                "documentationLink": "str",  # Optional. A link to a
                                  troubleshooting guide for these classes of errors. This may not be
                                  always available.
                                "key": "str",  # Optional. The key of the item for
                                  which indexing failed.
                                "name": "str"  # Optional. The name of the source at
                                  which the error originated. For example, this could refer to a
                                  particular skill in the attached skillset. This may not be always
                                  available.
                            }
                        ],
                        "itemsFailed": 0,  # The number of items that failed to be indexed
                          during this indexer execution. Required.
                        "itemsProcessed": 0,  # The number of items that were processed
                          during this indexer execution. This includes both successfully processed
                          items and items where indexing was attempted but failed. Required.
                        "status": "str",  # The outcome of this indexer execution. Required.
                          Known values are: "transientFailure", "success", "inProgress", and "reset".
                        "warnings": [
                            {
                                "message": "str",  # The message describing the
                                  warning that occurred while processing the item. Required.
                                "details": "str",  # Optional. Additional, verbose
                                  details about the warning to assist in debugging the indexer. This
                                  may not be always available.
                                "documentationLink": "str",  # Optional. A link to a
                                  troubleshooting guide for these classes of warnings. This may not be
                                  always available.
                                "key": "str",  # Optional. The key of the item which
                                  generated a warning.
                                "name": "str"  # Optional. The name of the source at
                                  which the warning originated. For example, this could refer to a
                                  particular skill in the attached skillset. This may not be always
                                  available.
                            }
                        ],
                        "endTime": "2020-02-20 00:00:00",  # Optional. The end time of this
                          indexer execution, if the execution has already completed.
                        "errorMessage": "str",  # Optional. The error message indicating the
                          top-level error, if any.
                        "finalTrackingState": "str",  # Optional. Change tracking state with
                          which an indexer execution finished.
                        "initialTrackingState": "str",  # Optional. Change tracking state
                          with which an indexer execution started.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The start time of
                          this indexer execution.
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchIndexerStatus] = kwargs.pop("cls", None)

        _request = build_indexers_operations_get_status_request(
            indexer_name=indexer_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexerStatus, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class SkillsetsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.search.documents.aio.SearchClient`'s
        :attr:`skillsets_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create_or_update(
        self,
        skillset_name: str,
        skillset: _models.SearchIndexerSkillset,
        *,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service or updates the skillset if it
        already exists.

        :param skillset_name: The name of the skillset. Required.
        :type skillset_name: str
        :param skillset: The skillset containing one or more skills to create or update in a search
         service. Required.
        :type skillset: ~azure.search.documents.models.SearchIndexerSkillset
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template you can fill out and use as your body input.
                skillset = {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        skillset_name: str,
        skillset: JSON,
        *,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service or updates the skillset if it
        already exists.

        :param skillset_name: The name of the skillset. Required.
        :type skillset_name: str
        :param skillset: The skillset containing one or more skills to create or update in a search
         service. Required.
        :type skillset: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        skillset_name: str,
        skillset: IO[bytes],
        *,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service or updates the skillset if it
        already exists.

        :param skillset_name: The name of the skillset. Required.
        :type skillset_name: str
        :param skillset: The skillset containing one or more skills to create or update in a search
         service. Required.
        :type skillset: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        skillset_name: str,
        skillset: Union[_models.SearchIndexerSkillset, JSON, IO[bytes]],
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service or updates the skillset if it
        already exists.

        :param skillset_name: The name of the skillset. Required.
        :type skillset_name: str
        :param skillset: The skillset containing one or more skills to create or update in a search
         service. Is one of the following types: SearchIndexerSkillset, JSON, IO[bytes] Required.
        :type skillset: ~azure.search.documents.models.SearchIndexerSkillset or JSON or IO[bytes]
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template you can fill out and use as your body input.
                skillset = {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        prefer: Literal["return=representation"] = kwargs.pop("prefer")
        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndexerSkillset] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(skillset, (IOBase, bytes)):
            _content = skillset
        else:
            _content = json.dumps(skillset, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_skillsets_operations_create_or_update_request(
            skillset_name=skillset_name,
            etag=etag,
            match_condition=match_condition,
            prefer=prefer,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexerSkillset, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        skillset_name: str,
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a skillset in a search service.

        :param skillset_name: The name of the skillset. Required.
        :type skillset_name: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_skillsets_operations_delete_request(
            skillset_name=skillset_name,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get(self, skillset_name: str, **kwargs: Any) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Retrieves a skillset in a search service.

        :param skillset_name: The name of the skillset. Required.
        :type skillset_name: str
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchIndexerSkillset] = kwargs.pop("cls", None)

        _request = build_skillsets_operations_get_request(
            skillset_name=skillset_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexerSkillset, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list(self, *, _select: Optional[str] = None, **kwargs: Any) -> _models.ListSkillsetsResult:
        # pylint: disable=line-too-long
        """List all skillsets in a search service.

        :keyword _select: Selects which top-level properties to retrieve.
         Specified as a comma-separated list of JSON property names,
         or '*' for all properties. The default is all properties. Default value is None.
        :paramtype _select: str
        :return: ListSkillsetsResult. The ListSkillsetsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.ListSkillsetsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "name": "str",  # The name of the skillset. Required.
                            "skills": [
                                search_indexer_skill
                            ],
                            "@odata.etag": "str",  # Optional. The ETag of the skillset.
                            "cognitiveServices": cognitive_services_account,
                            "description": "str",  # Optional. The description of the
                              skillset.
                            "encryptionKey": {
                                "keyVaultKeyName": "str",  # The name of your Azure
                                  Key Vault key to be used to encrypt your data at rest. Required.
                                "keyVaultKeyVersion": "str",  # The version of your
                                  Azure Key Vault key to be used to encrypt your data at rest.
                                  Required.
                                "keyVaultUri": "str",  # The URI of your Azure Key
                                  Vault, also referred to as DNS name, that contains the key to be used
                                  to encrypt your data at rest. An example URI might be
                                  ``https://my-keyvault-name.vault.azure.net``. Required.
                                "accessCredentials": {
                                    "applicationId": "str",  # An AAD Application
                                      ID that was granted the required access permissions to the Azure
                                      Key Vault that is to be used when encrypting your data at rest.
                                      The Application ID should not be confused with the Object ID for
                                      your AAD Application. Required.
                                    "applicationSecret": "str"  # Optional. The
                                      authentication key of the specified AAD application.
                                }
                            },
                            "indexProjections": {
                                "selectors": [
                                    {
                                        "mappings": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "parentKeyFieldName": "str",  # Name
                                          of the field in the search index to map the parent document's
                                          key value to. Must be a string field that is filterable and
                                          not the key field. Required.
                                        "sourceContext": "str",  # Source
                                          context for the projections. Represents the cardinality at
                                          which the document will be split into multiple sub documents.
                                          Required.
                                        "targetIndexName": "str"  # Name of
                                          the search index to project to. Must have a key field with
                                          the 'keyword' analyzer set. Required.
                                    }
                                ],
                                "parameters": {
                                    "projectionMode": "str"  # Optional. Defines
                                      behavior of the index projections in relation to the rest of the
                                      indexer. Known values are: "skipIndexingParentDocuments" and
                                      "includeIndexingParentDocuments".
                                }
                            },
                            "knowledgeStore": {
                                "projections": [
                                    {
                                        "files": [
                                            {
                                                "storageContainer":
                                                  "str",  # Blob container to store projections in.
                                                  Required.
                                                "generatedKeyName":
                                                  "str",  # Optional. Name of generated key to store
                                                  projection under.
                                                "inputs": [
                                                    {
                "name": "str",  # The name of the input.
                                                          Required.
                "inputs": [
                ...
                                                        ],
                "source": "str",  # Optional. The source of
                                                          the input.
                "sourceContext": "str"  # Optional. The
                                                          source context used for selecting recursive
                                                          inputs.
                                                    }
                                                ],
                                                "referenceKeyName":
                                                  "str",  # Optional. Name of reference key to
                                                  different projection.
                                                "source": "str",  #
                                                  Optional. Source data to project.
                                                "sourceContext":
                                                  "str"  # Optional. Source context for complex
                                                  projections.
                                            }
                                        ],
                                        "objects": [
                                            {
                                                "storageContainer":
                                                  "str",  # Blob container to store projections in.
                                                  Required.
                                                "generatedKeyName":
                                                  "str",  # Optional. Name of generated key to store
                                                  projection under.
                                                "inputs": [
                                                    {
                "name": "str",  # The name of the input.
                                                          Required.
                "inputs": [
                ...
                                                        ],
                "source": "str",  # Optional. The source of
                                                          the input.
                "sourceContext": "str"  # Optional. The
                                                          source context used for selecting recursive
                                                          inputs.
                                                    }
                                                ],
                                                "referenceKeyName":
                                                  "str",  # Optional. Name of reference key to
                                                  different projection.
                                                "source": "str",  #
                                                  Optional. Source data to project.
                                                "sourceContext":
                                                  "str"  # Optional. Source context for complex
                                                  projections.
                                            }
                                        ],
                                        "tables": [
                                            {
                                                "tableName": "str",
                                                  # Name of the Azure table to store projected data in.
                                                  Required.
                                                "generatedKeyName":
                                                  "str",  # Optional. Name of generated key to store
                                                  projection under.
                                                "inputs": [
                                                    {
                "name": "str",  # The name of the input.
                                                          Required.
                "inputs": [
                ...
                                                        ],
                "source": "str",  # Optional. The source of
                                                          the input.
                "sourceContext": "str"  # Optional. The
                                                          source context used for selecting recursive
                                                          inputs.
                                                    }
                                                ],
                                                "referenceKeyName":
                                                  "str",  # Optional. Name of reference key to
                                                  different projection.
                                                "source": "str",  #
                                                  Optional. Source data to project.
                                                "sourceContext":
                                                  "str"  # Optional. Source context for complex
                                                  projections.
                                            }
                                        ]
                                    }
                                ],
                                "storageConnectionString": "str"  # The connection
                                  string to the storage account projections will be stored in.
                                  Required.
                            }
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListSkillsetsResult] = kwargs.pop("cls", None)

        _request = build_skillsets_operations_list_request(
            _select=_select,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ListSkillsetsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self, skillset: _models.SearchIndexerSkillset, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service.

        :param skillset: The skillset containing one or more skills to create in a search service.
         Required.
        :type skillset: ~azure.search.documents.models.SearchIndexerSkillset
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template you can fill out and use as your body input.
                skillset = {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @overload
    async def create(
        self, skillset: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service.

        :param skillset: The skillset containing one or more skills to create in a search service.
         Required.
        :type skillset: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @overload
    async def create(
        self, skillset: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service.

        :param skillset: The skillset containing one or more skills to create in a search service.
         Required.
        :type skillset: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @distributed_trace_async
    async def create(
        self, skillset: Union[_models.SearchIndexerSkillset, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SearchIndexerSkillset:
        # pylint: disable=line-too-long
        """Creates a new skillset in a search service.

        :param skillset: The skillset containing one or more skills to create in a search service. Is
         one of the following types: SearchIndexerSkillset, JSON, IO[bytes] Required.
        :type skillset: ~azure.search.documents.models.SearchIndexerSkillset or JSON or IO[bytes]
        :return: SearchIndexerSkillset. The SearchIndexerSkillset is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerSkillset
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template you can fill out and use as your body input.
                skillset = {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the Azure AI service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the Azure AI service
                      resource attached to a skillset.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "indexProjections": {
                        "selectors": [
                            {
                                "mappings": [
                                    {
                                        "name": "str",  # The name of the
                                          input. Required.
                                        "inputs": [
                                            ...
                                        ],
                                        "source": "str",  # Optional. The
                                          source of the input.
                                        "sourceContext": "str"  # Optional.
                                          The source context used for selecting recursive inputs.
                                    }
                                ],
                                "parentKeyFieldName": "str",  # Name of the field in
                                  the search index to map the parent document's key value to. Must be a
                                  string field that is filterable and not the key field. Required.
                                "sourceContext": "str",  # Source context for the
                                  projections. Represents the cardinality at which the document will be
                                  split into multiple sub documents. Required.
                                "targetIndexName": "str"  # Name of the search index
                                  to project to. Must have a key field with the 'keyword' analyzer set.
                                  Required.
                            }
                        ],
                        "parameters": {
                            "projectionMode": "str"  # Optional. Defines behavior of the
                              index projections in relation to the rest of the indexer. Known values
                              are: "skipIndexingParentDocuments" and "includeIndexingParentDocuments".
                        }
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndexerSkillset] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(skillset, (IOBase, bytes)):
            _content = skillset
        else:
            _content = json.dumps(skillset, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_skillsets_operations_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexerSkillset, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class SynonymMapsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.search.documents.aio.SearchClient`'s
        :attr:`synonym_maps_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create_or_update(
        self,
        synonym_map_name: str,
        synonym_map: _models.SynonymMap,
        *,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map or updates a synonym map if it already exists.

        :param synonym_map_name: The name of the synonym map. Required.
        :type synonym_map_name: str
        :param synonym_map: The definition of the synonym map to create or update. Required.
        :type synonym_map: ~azure.search.documents.models.SynonymMap
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                synonym_map = {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        synonym_map_name: str,
        synonym_map: JSON,
        *,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map or updates a synonym map if it already exists.

        :param synonym_map_name: The name of the synonym map. Required.
        :type synonym_map_name: str
        :param synonym_map: The definition of the synonym map to create or update. Required.
        :type synonym_map: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        synonym_map_name: str,
        synonym_map: IO[bytes],
        *,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map or updates a synonym map if it already exists.

        :param synonym_map_name: The name of the synonym map. Required.
        :type synonym_map_name: str
        :param synonym_map: The definition of the synonym map to create or update. Required.
        :type synonym_map: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        synonym_map_name: str,
        synonym_map: Union[_models.SynonymMap, JSON, IO[bytes]],
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map or updates a synonym map if it already exists.

        :param synonym_map_name: The name of the synonym map. Required.
        :type synonym_map_name: str
        :param synonym_map: The definition of the synonym map to create or update. Is one of the
         following types: SynonymMap, JSON, IO[bytes] Required.
        :type synonym_map: ~azure.search.documents.models.SynonymMap or JSON or IO[bytes]
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                synonym_map = {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        prefer: Literal["return=representation"] = kwargs.pop("prefer")
        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SynonymMap] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(synonym_map, (IOBase, bytes)):
            _content = synonym_map
        else:
            _content = json.dumps(synonym_map, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_synonym_maps_operations_create_or_update_request(
            synonym_map_name=synonym_map_name,
            etag=etag,
            match_condition=match_condition,
            prefer=prefer,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SynonymMap, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        synonym_map_name: str,
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a synonym map.

        :param synonym_map_name: The name of the synonym map. Required.
        :type synonym_map_name: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_synonym_maps_operations_delete_request(
            synonym_map_name=synonym_map_name,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get(self, synonym_map_name: str, **kwargs: Any) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Retrieves a synonym map definition.

        :param synonym_map_name: The name of the synonym map. Required.
        :type synonym_map_name: str
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SynonymMap] = kwargs.pop("cls", None)

        _request = build_synonym_maps_operations_get_request(
            synonym_map_name=synonym_map_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SynonymMap, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list(self, *, _select: Optional[str] = None, **kwargs: Any) -> _models.ListSynonymMapsResult:
        # pylint: disable=line-too-long
        """Lists all synonym maps available for a search service.

        :keyword _select: Selects which top-level properties to retrieve.
         Specified as a comma-separated list of JSON property names,
         or '*' for all properties. The default is all properties. Default value is None.
        :paramtype _select: str
        :return: ListSynonymMapsResult. The ListSynonymMapsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.ListSynonymMapsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "format": "solr",  # Default value is "solr". The format of
                              the synonym map. Only the 'solr' format is currently supported. Required.
                            "name": "str",  # The name of the synonym map. Required.
                            "synonyms": "str",  # A series of synonym rules in the
                              specified synonym map format. The rules must be separated by newlines.
                              Required.
                            "@odata.etag": "str",  # Optional. The ETag of the synonym
                              map.
                            "encryptionKey": {
                                "keyVaultKeyName": "str",  # The name of your Azure
                                  Key Vault key to be used to encrypt your data at rest. Required.
                                "keyVaultKeyVersion": "str",  # The version of your
                                  Azure Key Vault key to be used to encrypt your data at rest.
                                  Required.
                                "keyVaultUri": "str",  # The URI of your Azure Key
                                  Vault, also referred to as DNS name, that contains the key to be used
                                  to encrypt your data at rest. An example URI might be
                                  ``https://my-keyvault-name.vault.azure.net``. Required.
                                "accessCredentials": {
                                    "applicationId": "str",  # An AAD Application
                                      ID that was granted the required access permissions to the Azure
                                      Key Vault that is to be used when encrypting your data at rest.
                                      The Application ID should not be confused with the Object ID for
                                      your AAD Application. Required.
                                    "applicationSecret": "str"  # Optional. The
                                      authentication key of the specified AAD application.
                                }
                            }
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListSynonymMapsResult] = kwargs.pop("cls", None)

        _request = build_synonym_maps_operations_list_request(
            _select=_select,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ListSynonymMapsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self, synonym_map: _models.SynonymMap, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map.

        :param synonym_map: The definition of the synonym map to create. Required.
        :type synonym_map: ~azure.search.documents.models.SynonymMap
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                synonym_map = {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create(
        self, synonym_map: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map.

        :param synonym_map: The definition of the synonym map to create. Required.
        :type synonym_map: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def create(
        self, synonym_map: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map.

        :param synonym_map: The definition of the synonym map to create. Required.
        :type synonym_map: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @distributed_trace_async
    async def create(
        self, synonym_map: Union[_models.SynonymMap, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SynonymMap:
        # pylint: disable=line-too-long
        """Creates a new synonym map.

        :param synonym_map: The definition of the synonym map to create. Is one of the following types:
         SynonymMap, JSON, IO[bytes] Required.
        :type synonym_map: ~azure.search.documents.models.SynonymMap or JSON or IO[bytes]
        :return: SynonymMap. The SynonymMap is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SynonymMap
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                synonym_map = {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SynonymMap] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(synonym_map, (IOBase, bytes)):
            _content = synonym_map
        else:
            _content = json.dumps(synonym_map, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_synonym_maps_operations_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SynonymMap, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class IndexesOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.search.documents.aio.SearchClient`'s
        :attr:`indexes_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self, index: _models.SearchIndex, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index.

        :param index: The definition of the index to create. Required.
        :type index: ~azure.search.documents.models.SearchIndex
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # JSON input template you can fill out and use as your body input.
                index = {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # File name.
                                          Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # File name.
                                          Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """

    @overload
    async def create(
        self, index: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index.

        :param index: The definition of the index to create. Required.
        :type index: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # File name.
                                          Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """

    @overload
    async def create(
        self, index: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index.

        :param index: The definition of the index to create. Required.
        :type index: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # File name.
                                          Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """

    @distributed_trace_async
    async def create(self, index: Union[_models.SearchIndex, JSON, IO[bytes]], **kwargs: Any) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index.

        :param index: The definition of the index to create. Is one of the following types:
         SearchIndex, JSON, IO[bytes] Required.
        :type index: ~azure.search.documents.models.SearchIndex or JSON or IO[bytes]
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # JSON input template you can fill out and use as your body input.
                index = {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # File name.
                                          Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # File name.
                                          Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndex] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(index, (IOBase, bytes)):
            _content = index
        else:
            _content = json.dumps(index, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_indexes_operations_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndex, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(self, *, _select: Optional[str] = None, **kwargs: Any) -> AsyncIterable["_models.SearchIndex"]:
        # pylint: disable=line-too-long
        """Lists all indexes available for a search service.

        :keyword _select: Selects which top-level properties to retrieve.
         Specified as a comma-separated list of JSON property names,
         or '*' for all properties. The default is all properties. Default value is None.
        :paramtype _select: str
        :return: An iterator like instance of SearchIndex
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.search.documents.models.SearchIndex]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # File name.
                                          Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SearchIndex]] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_indexes_operations_list_request(
                    _select=_select,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.SearchIndex], deserialized["indexes"])
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    await response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def create_or_update(
        self,
        index_name: str,
        index: _models.SearchIndex,
        *,
        allow_index_downtime: Optional[bool] = None,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index or updates an index if it already exists.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param index: The definition of the index to create or update. Required.
        :type index: ~azure.search.documents.models.SearchIndex
        :keyword allow_index_downtime: Allows new analyzers, tokenizers, token filters, or char filters
         to be added to
         an index by taking the index offline for at least a few seconds. This
         temporarily causes indexing and query requests to fail. Performance and write
         availability of the index can be impaired for several minutes after the index
         is updated, or longer for very large indexes. Default value is None.
        :paramtype allow_index_downtime: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # JSON input template you can fill out and use as your body input.
                index = {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # File name.
                                          Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # File name.
                                          Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        index_name: str,
        index: JSON,
        *,
        allow_index_downtime: Optional[bool] = None,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index or updates an index if it already exists.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param index: The definition of the index to create or update. Required.
        :type index: JSON
        :keyword allow_index_downtime: Allows new analyzers, tokenizers, token filters, or char filters
         to be added to
         an index by taking the index offline for at least a few seconds. This
         temporarily causes indexing and query requests to fail. Performance and write
         availability of the index can be impaired for several minutes after the index
         is updated, or longer for very large indexes. Default value is None.
        :paramtype allow_index_downtime: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # File name.
                                          Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        index_name: str,
        index: IO[bytes],
        *,
        allow_index_downtime: Optional[bool] = None,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index or updates an index if it already exists.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param index: The definition of the index to create or update. Required.
        :type index: IO[bytes]
        :keyword allow_index_downtime: Allows new analyzers, tokenizers, token filters, or char filters
         to be added to
         an index by taking the index offline for at least a few seconds. This
         temporarily causes indexing and query requests to fail. Performance and write
         availability of the index can be impaired for several minutes after the index
         is updated, or longer for very large indexes. Default value is None.
        :paramtype allow_index_downtime: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # File name.
                                          Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        index_name: str,
        index: Union[_models.SearchIndex, JSON, IO[bytes]],
        *,
        allow_index_downtime: Optional[bool] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Creates a new search index or updates an index if it already exists.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param index: The definition of the index to create or update. Is one of the following types:
         SearchIndex, JSON, IO[bytes] Required.
        :type index: ~azure.search.documents.models.SearchIndex or JSON or IO[bytes]
        :keyword allow_index_downtime: Allows new analyzers, tokenizers, token filters, or char filters
         to be added to
         an index by taking the index offline for at least a few seconds. This
         temporarily causes indexing and query requests to fail. Performance and write
         availability of the index can be impaired for several minutes after the index
         is updated, or longer for very large indexes. Default value is None.
        :paramtype allow_index_downtime: bool
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # JSON input template you can fill out and use as your body input.
                index = {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # File name.
                                          Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # File name.
                                          Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        prefer: Literal["return=representation"] = kwargs.pop("prefer")
        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndex] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(index, (IOBase, bytes)):
            _content = index
        else:
            _content = json.dumps(index, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_indexes_operations_create_or_update_request(
            index_name=index_name,
            allow_index_downtime=allow_index_downtime,
            etag=etag,
            match_condition=match_condition,
            prefer=prefer,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndex, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        index_name: str,
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a search index and all the documents it contains. This operation is
        permanent, with no recovery option. Make sure you have a master copy of your
        index definition, data ingestion code, and a backup of the primary data source
        in case you need to re-build the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_indexes_operations_delete_request(
            index_name=index_name,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get(self, index_name: str, **kwargs: Any) -> _models.SearchIndex:
        # pylint: disable=line-too-long
        """Retrieves an index definition.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :return: SearchIndex. The SearchIndex is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndex
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity_algorithm = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity_algorithm = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint",
                              "Edm.ComplexType", "Edm.Single", "Edm.Half", "Edm.Int16", "Edm.SByte",
                              and "Edm.Byte".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "dimensions": 0,  # Optional. The dimensionality of the
                              vector field.
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields, false for vector fields, and null for
                              complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index to accommodate
                              additional tokenized versions of the field value for full-text searches.
                              If you want to save space in your index and you don't need a field to be
                              included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default,
                              the search engine sorts results by score, but in many experiences users
                              will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "stored": bool,  # Optional. An immutable value indicating
                              whether the field will be persisted separately on disk to be returned in
                              a search result. You can disable this option if you don't plan to return
                              the field contents in a search response to save on storage overhead. This
                              can only be set during index creation and only for vector fields. This
                              property cannot be changed for existing fields or set as false for new
                              fields. If this property is set as false, the property 'retrievable' must
                              also be set to false. This property must be true or unset for key fields,
                              for new fields, and for non-vector fields, and it must be null for
                              complex fields. Disabling this property will reduce index storage
                              requirements. The default is true for vector fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ],
                            "vectorEncoding": "str",  # Optional. The encoding format to
                              interpret the field contents. "packedBit"
                            "vectorSearchProfile": "str"  # Optional. The name of the
                              vector search profile that specifies the algorithm and vectorizer to use
                              when searching the vector field.
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    },
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  # File
                                              name. Required.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # File name.
                                          Required.
                                    }
                                }
                            }
                        ],
                        "defaultConfiguration": "str"  # Optional. Allows you to set the name
                          of a default semantic configuration in your index, making it optional to pass
                          it on as a query parameter every time.
                    },
                    "similarity": similarity_algorithm,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ],
                    "vectorSearch": {
                        "algorithms": [
                            vector_search_algorithm_configuration
                        ],
                        "compressions": [
                            vector_search_compression
                        ],
                        "profiles": [
                            {
                                "algorithm": "str",  # The name of the vector search
                                  algorithm configuration that specifies the algorithm and optional
                                  parameters. Required.
                                "name": "str",  # The name to associate with this
                                  particular vector search profile. Required.
                                "compression": "str",  # Optional. The name of the
                                  compression method configuration that specifies the compression
                                  method and optional parameters.
                                "vectorizer": "str"  # Optional. The name of the
                                  vectorization being configured for use with vector search.
                            }
                        ],
                        "vectorizers": [
                            vector_search_vectorizer
                        ]
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchIndex] = kwargs.pop("cls", None)

        _request = build_indexes_operations_get_request(
            index_name=index_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndex, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_statistics(self, index_name: str, **kwargs: Any) -> _models.GetIndexStatisticsResult:
        """Returns statistics for the given index, including a document count and storage
        usage.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :return: GetIndexStatisticsResult. The GetIndexStatisticsResult is compatible with
         MutableMapping
        :rtype: ~azure.search.documents.models.GetIndexStatisticsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "documentCount": 0,  # The number of documents in the index. Required.
                    "storageSize": 0,  # The amount of storage in bytes consumed by the index.
                      Required.
                    "vectorIndexSize": 0  # The amount of memory in bytes consumed by vectors in
                      the index. Required.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GetIndexStatisticsResult] = kwargs.pop("cls", None)

        _request = build_indexes_operations_get_statistics_request(
            index_name=index_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GetIndexStatisticsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def analyze(
        self, index_name: str, request: _models.AnalyzeRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AnalyzeResult:
        # pylint: disable=line-too-long
        """Shows how an analyzer breaks text into tokens.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param request: The text and analyzer or analysis components to test. Required.
        :type request: ~azure.search.documents.models.AnalyzeRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AnalyzeResult. The AnalyzeResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AnalyzeResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request = {
                    "text": "str",  # The text to break into tokens. Required.
                    "analyzer": "str",  # Optional. The name of the analyzer to use to break the
                      given text. If this parameter is not specified, you must specify a tokenizer
                      instead. The tokenizer and analyzer parameters are mutually exclusive. Known
                      values are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                      "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                      "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft", "zh-Hant.lucene",
                      "hr.microsoft", "cs.microsoft", "cs.lucene", "da.microsoft", "da.lucene",
                      "nl.microsoft", "nl.lucene", "en.microsoft", "en.lucene", "et.microsoft",
                      "fi.microsoft", "fi.lucene", "fr.microsoft", "fr.lucene", "gl.lucene",
                      "de.microsoft", "de.lucene", "el.microsoft", "el.lucene", "gu.microsoft",
                      "he.microsoft", "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene",
                      "is.microsoft", "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft",
                      "it.lucene", "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft",
                      "ko.lucene", "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                      "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                      "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                      "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft", "ro.lucene",
                      "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft", "sr-latin.microsoft",
                      "sk.microsoft", "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft",
                      "sv.lucene", "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                      "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft", "vi.microsoft",
                      "standard.lucene", "standardasciifolding.lucene", "keyword", "pattern", "simple",
                      "stop", and "whitespace".
                    "charFilters": [
                        "str"  # Optional. An optional list of character filters to use when
                          breaking the given text. This parameter can only be set when using the
                          tokenizer parameter.
                    ],
                    "tokenFilters": [
                        "str"  # Optional. An optional list of token filters to use when
                          breaking the given text. This parameter can only be set when using the
                          tokenizer parameter.
                    ],
                    "tokenizer": "str"  # Optional. The name of the tokenizer to use to break the
                      given text. If this parameter is not specified, you must specify an analyzer
                      instead. The tokenizer and analyzer parameters are mutually exclusive. Known
                      values are: "classic", "edgeNGram", "keyword_v2", "letter", "lowercase",
                      "microsoft_language_tokenizer", "microsoft_language_stemming_tokenizer", "nGram",
                      "path_hierarchy_v2", "pattern", "standard_v2", "uax_url_email", and "whitespace".
                }

                # response body for status code(s): 200
                response == {
                    "tokens": [
                        {
                            "endOffset": 0,  # The index of the last character of the
                              token in the input text. Required.
                            "position": 0,  # The position of the token in the input text
                              relative to other tokens. The first token in the input text has position
                              0, the next has position 1, and so on. Depending on the analyzer used,
                              some tokens might have the same position, for example if they are
                              synonyms of each other. Required.
                            "startOffset": 0,  # The index of the first character of the
                              token in the input text. Required.
                            "token": "str"  # The token returned by the analyzer.
                              Required.
                        }
                    ]
                }
        """

    @overload
    async def analyze(
        self, index_name: str, request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AnalyzeResult:
        # pylint: disable=line-too-long
        """Shows how an analyzer breaks text into tokens.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param request: The text and analyzer or analysis components to test. Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AnalyzeResult. The AnalyzeResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AnalyzeResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tokens": [
                        {
                            "endOffset": 0,  # The index of the last character of the
                              token in the input text. Required.
                            "position": 0,  # The position of the token in the input text
                              relative to other tokens. The first token in the input text has position
                              0, the next has position 1, and so on. Depending on the analyzer used,
                              some tokens might have the same position, for example if they are
                              synonyms of each other. Required.
                            "startOffset": 0,  # The index of the first character of the
                              token in the input text. Required.
                            "token": "str"  # The token returned by the analyzer.
                              Required.
                        }
                    ]
                }
        """

    @overload
    async def analyze(
        self, index_name: str, request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AnalyzeResult:
        # pylint: disable=line-too-long
        """Shows how an analyzer breaks text into tokens.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param request: The text and analyzer or analysis components to test. Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AnalyzeResult. The AnalyzeResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AnalyzeResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tokens": [
                        {
                            "endOffset": 0,  # The index of the last character of the
                              token in the input text. Required.
                            "position": 0,  # The position of the token in the input text
                              relative to other tokens. The first token in the input text has position
                              0, the next has position 1, and so on. Depending on the analyzer used,
                              some tokens might have the same position, for example if they are
                              synonyms of each other. Required.
                            "startOffset": 0,  # The index of the first character of the
                              token in the input text. Required.
                            "token": "str"  # The token returned by the analyzer.
                              Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def analyze(
        self, index_name: str, request: Union[_models.AnalyzeRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.AnalyzeResult:
        # pylint: disable=line-too-long
        """Shows how an analyzer breaks text into tokens.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param request: The text and analyzer or analysis components to test. Is one of the following
         types: AnalyzeRequest, JSON, IO[bytes] Required.
        :type request: ~azure.search.documents.models.AnalyzeRequest or JSON or IO[bytes]
        :return: AnalyzeResult. The AnalyzeResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AnalyzeResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request = {
                    "text": "str",  # The text to break into tokens. Required.
                    "analyzer": "str",  # Optional. The name of the analyzer to use to break the
                      given text. If this parameter is not specified, you must specify a tokenizer
                      instead. The tokenizer and analyzer parameters are mutually exclusive. Known
                      values are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                      "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                      "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft", "zh-Hant.lucene",
                      "hr.microsoft", "cs.microsoft", "cs.lucene", "da.microsoft", "da.lucene",
                      "nl.microsoft", "nl.lucene", "en.microsoft", "en.lucene", "et.microsoft",
                      "fi.microsoft", "fi.lucene", "fr.microsoft", "fr.lucene", "gl.lucene",
                      "de.microsoft", "de.lucene", "el.microsoft", "el.lucene", "gu.microsoft",
                      "he.microsoft", "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene",
                      "is.microsoft", "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft",
                      "it.lucene", "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft",
                      "ko.lucene", "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                      "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                      "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                      "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft", "ro.lucene",
                      "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft", "sr-latin.microsoft",
                      "sk.microsoft", "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft",
                      "sv.lucene", "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                      "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft", "vi.microsoft",
                      "standard.lucene", "standardasciifolding.lucene", "keyword", "pattern", "simple",
                      "stop", and "whitespace".
                    "charFilters": [
                        "str"  # Optional. An optional list of character filters to use when
                          breaking the given text. This parameter can only be set when using the
                          tokenizer parameter.
                    ],
                    "tokenFilters": [
                        "str"  # Optional. An optional list of token filters to use when
                          breaking the given text. This parameter can only be set when using the
                          tokenizer parameter.
                    ],
                    "tokenizer": "str"  # Optional. The name of the tokenizer to use to break the
                      given text. If this parameter is not specified, you must specify an analyzer
                      instead. The tokenizer and analyzer parameters are mutually exclusive. Known
                      values are: "classic", "edgeNGram", "keyword_v2", "letter", "lowercase",
                      "microsoft_language_tokenizer", "microsoft_language_stemming_tokenizer", "nGram",
                      "path_hierarchy_v2", "pattern", "standard_v2", "uax_url_email", and "whitespace".
                }

                # response body for status code(s): 200
                response == {
                    "tokens": [
                        {
                            "endOffset": 0,  # The index of the last character of the
                              token in the input text. Required.
                            "position": 0,  # The position of the token in the input text
                              relative to other tokens. The first token in the input text has position
                              0, the next has position 1, and so on. Depending on the analyzer used,
                              some tokens might have the same position, for example if they are
                              synonyms of each other. Required.
                            "startOffset": 0,  # The index of the first character of the
                              token in the input text. Required.
                            "token": "str"  # The token returned by the analyzer.
                              Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AnalyzeResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_indexes_operations_analyze_request(
            index_name=index_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AnalyzeResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class DocumentsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.search.documents.aio.SearchClient`'s
        :attr:`documents_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def count(self, index_name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Queries the number of documents in the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_documents_operations_count_request(
            index_name=index_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def search_get(
        self,
        index_name: str,
        *,
        search_text: Optional[str] = None,
        include_total_result_count: Optional[bool] = None,
        facets: Optional[List[str]] = None,
        _filter: Optional[str] = None,
        highlight_fields: Optional[List[str]] = None,
        highlight_post_tag: Optional[str] = None,
        highlight_pre_tag: Optional[str] = None,
        minimum_coverage: Optional[float] = None,
        order_by: Optional[List[str]] = None,
        query_type: Optional[Union[str, _models.QueryType]] = None,
        scoring_parameters: Optional[List[str]] = None,
        scoring_profile: Optional[str] = None,
        search_fields: Optional[List[str]] = None,
        search_mode: Optional[Union[str, _models.SearchMode]] = None,
        scoring_statistics: Optional[Union[str, _models.ScoringStatistics]] = None,
        session_id: Optional[str] = None,
        _select: Optional[List[str]] = None,
        _skip: Optional[int] = None,
        _top: Optional[int] = None,
        semantic_configuration: Optional[str] = None,
        semantic_error_handling: Optional[Union[str, _models.SemanticErrorMode]] = None,
        semantic_max_wait_in_milliseconds: Optional[int] = None,
        answers: Optional[Union[str, _models.QueryAnswerType]] = None,
        captions: Optional[Union[str, _models.QueryCaptionType]] = None,
        semantic_query: Optional[str] = None,
        **kwargs: Any
    ) -> _models.SearchDocumentsResult:
        # pylint: disable=line-too-long
        """Searches for documents in the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :keyword search_text: A full-text search query expression; Use "*" or omit this parameter to
         match
         all documents. Default value is None.
        :paramtype search_text: str
        :keyword include_total_result_count: A value that specifies whether to fetch the total count of
         results. Default is
         false. Setting this value to true may have a performance impact. Note that the
         count returned is an approximation. Default value is None.
        :paramtype include_total_result_count: bool
        :keyword facets: The list of facet expressions to apply to the search query. Each facet
         expression contains a field name, optionally followed by a comma-separated list
         of name:value pairs. Default value is None.
        :paramtype facets: list[str]
        :keyword _filter: The OData $filter expression to apply to the search query. Default value is
         None.
        :paramtype _filter: str
        :keyword highlight_fields: The list of field names to use for hit highlights. Only searchable
         fields can
         be used for hit highlighting. Default value is None.
        :paramtype highlight_fields: list[str]
        :keyword highlight_post_tag: A string tag that is appended to hit highlights. Must be set with
         highlightPreTag. Default is &lt;/em&gt;. Default value is None.
        :paramtype highlight_post_tag: str
        :keyword highlight_pre_tag: A string tag that is prepended to hit highlights. Must be set with
         highlightPostTag. Default is &lt;em&gt;. Default value is None.
        :paramtype highlight_pre_tag: str
        :keyword minimum_coverage: A number between 0 and 100 indicating the percentage of the index
         that must be
         covered by a search query in order for the query to be reported as a success.
         This parameter can be useful for ensuring search availability even for services
         with only one replica. The default is 100. Default value is None.
        :paramtype minimum_coverage: float
        :keyword order_by: The list of OData $orderby expressions by which to sort the results. Each
         expression can be either a field name or a call to either the geo.distance() or
         the search.score() functions. Each expression can be followed by asc to
         indicate ascending, and desc to indicate descending. The default is ascending
         order. Ties will be broken by the match scores of documents. If no OrderBy is
         specified, the default sort order is descending by document match score. There
         can be at most 32 $orderby clauses. Default value is None.
        :paramtype order_by: list[str]
        :keyword query_type: A value that specifies the syntax of the search query. The default is
         'simple'.
         Use 'full' if your query uses the Lucene query syntax. Known values are: "simple", "full", and
         "semantic". Default value is None.
        :paramtype query_type: str or ~azure.search.documents.models.QueryType
        :keyword scoring_parameters: The list of parameter values to be used in scoring functions (for
         example,
         referencePointParameter) using the format name-values. For example, if the
         scoring profile defines a function with a parameter called 'mylocation' the
         parameter string would be "mylocation--122.2,44.8" (without the quotes). Default value is
         None.
        :paramtype scoring_parameters: list[str]
        :keyword scoring_profile: The name of a scoring profile to evaluate match scores for matching
         documents
         in order to sort the results. Default value is None.
        :paramtype scoring_profile: str
        :keyword search_fields: The list of field names to which to scope the full-text search. When
         using
         fielded search (fieldName:searchExpression) in a full Lucene query, the field
         names of each fielded search expression take precedence over any field names
         listed in this parameter. Default value is None.
        :paramtype search_fields: list[str]
        :keyword search_mode: A value that specifies whether any or all of the search terms must be
         matched
         in order to count the document as a match. Known values are: "any" and "all". Default value is
         None.
        :paramtype search_mode: str or ~azure.search.documents.models.SearchMode
        :keyword scoring_statistics: A value that specifies whether we want to calculate scoring
         statistics (such as
         document frequency) globally for more consistent scoring, or locally, for lower
         latency. Known values are: "local" and "global". Default value is None.
        :paramtype scoring_statistics: str or ~azure.search.documents.models.ScoringStatistics
        :keyword session_id: A value to be used to create a sticky session, which can help to get more
         consistent results. As long as the same sessionId is used, a best-effort
         attempt will be made to target the same replica set. Be wary that reusing the
         same sessionID values repeatedly can interfere with the load balancing of the
         requests across replicas and adversely affect the performance of the search
         service. The value used as sessionId cannot start with a '_' character. Default value is None.
        :paramtype session_id: str
        :keyword _select: The list of fields to retrieve. If unspecified, all fields marked as
         retrievable in the schema are included. Default value is None.
        :paramtype _select: list[str]
        :keyword _skip: The number of search results to skip. This value cannot be greater than
         100,000. If you need to scan documents in sequence, but cannot use $skip due to
         this limitation, consider using $orderby on a totally-ordered key and $filter
         with a range query instead. Default value is None.
        :paramtype _skip: int
        :keyword _top: The number of search results to retrieve. This can be used in conjunction with
         $skip to implement client-side paging of search results. If results are
         truncated due to server-side paging, the response will include a continuation
         token that can be used to issue another Search request for the next page of
         results. Default value is None.
        :paramtype _top: int
        :keyword semantic_configuration: The name of the semantic configuration that lists which fields
         should be used
         for semantic ranking, captions, highlights, and answers. Default value is None.
        :paramtype semantic_configuration: str
        :keyword semantic_error_handling: Allows the user to choose whether a semantic call should fail
         completely, or to
         return partial results (default). Known values are: "partial" and "fail". Default value is
         None.
        :paramtype semantic_error_handling: str or ~azure.search.documents.models.SemanticErrorMode
        :keyword semantic_max_wait_in_milliseconds: Allows the user to set an upper bound on the amount
         of time it takes for
         semantic enrichment to finish processing before the request fails. Default value is None.
        :paramtype semantic_max_wait_in_milliseconds: int
        :keyword answers: This parameter is only valid if the query type is ``semantic``. If set, the
         query
         returns answers extracted from key passages in the highest ranked documents.
         The number of answers returned can be configured by appending the pipe
         character ``|`` followed by the ``count-<number of answers>`` option after the
         answers parameter value, such as ``extractive|count-3``. Default count is 1. The
         confidence threshold can be configured by appending the pipe character ``|``
         followed by the ``threshold-<confidence threshold>`` option after the answers
         parameter value, such as ``extractive|threshold-0.9``. Default threshold is 0.7. Known values
         are: "none" and "extractive". Default value is None.
        :paramtype answers: str or ~azure.search.documents.models.QueryAnswerType
        :keyword captions: This parameter is only valid if the query type is ``semantic``. If set, the
         query
         returns captions extracted from key passages in the highest ranked documents.
         When Captions is set to ``extractive``\\ , highlighting is enabled by default, and
         can be configured by appending the pipe character ``|`` followed by the
         ``highlight-<true/false>`` option, such as ``extractive|highlight-true``. Defaults
         to ``None``. Known values are: "none" and "extractive". Default value is None.
        :paramtype captions: str or ~azure.search.documents.models.QueryCaptionType
        :keyword semantic_query: Allows setting a separate search query that will be solely used for
         semantic
         reranking, semantic captions and semantic answers. Is useful for scenarios
         where there is a need to use different queries between the base retrieval and
         ranking phase, and the L2 semantic phase. Default value is None.
        :paramtype semantic_query: str
        :return: SearchDocumentsResult. The SearchDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.score": 0.0,  # The relevance score of the document
                              compared to other documents returned by the query. Required.
                            "@search.captions": [
                                {
                                    "highlights": "str",  # Optional. Same text
                                      passage as in the Text property with highlighted phrases most
                                      relevant to the query.
                                    "text": "str"  # Optional. A representative
                                      text passage extracted from the document most relevant to the
                                      search query.
                                }
                            ],
                            "@search.highlights": {
                                "str": [
                                    "str"  # Optional. Text fragments from the
                                      document that indicate the matching search terms, organized by
                                      each applicable field; null if hit highlighting was not enabled
                                      for the query.
                                ]
                            },
                            "@search.rerankerScore": 0.0  # Optional. The relevance score
                              computed by the semantic ranker for the top search results. Search
                              results are sorted by the RerankerScore first and then by the Score.
                              RerankerScore is only returned for queries of type 'semantic'.
                        }
                    ],
                    "@odata.count": 0,  # Optional. The total count of results found by the
                      search operation, or null if the count was not requested. If present, the count
                      may be greater than the number of results in this response. This can happen if
                      you use the $top or $skip parameters, or if the query can't return all the
                      requested documents in a single response.
                    "@odata.nextLink": "str",  # Optional. Continuation URL returned when the
                      query can't return all the requested results in a single response. You can use
                      this URL to formulate another GET or POST Search request to get the next part of
                      the search response. Make sure to use the same verb (GET or POST) as the request
                      that produced this response.
                    "@search.answers": [
                        {
                            "highlights": "str",  # Optional. Same text passage as in the
                              Text property with highlighted text phrases most relevant to the query.
                            "key": "str",  # Optional. The key of the document the answer
                              was extracted from.
                            "score": 0.0,  # Optional. The score value represents how
                              relevant the answer is to the query relative to other answers returned
                              for the query.
                            "text": "str"  # Optional. The text passage extracted from
                              the document contents as the answer.
                        }
                    ],
                    "@search.coverage": 0.0,  # Optional. A value indicating the percentage of
                      the index that was included in the query, or null if minimumCoverage was not
                      specified in the request.
                    "@search.facets": {
                        "str": [
                            {
                                "count": 0  # Optional. The approximate count of
                                  documents falling within the bucket described by this facet.
                            }
                        ]
                    },
                    "@search.nextPageParameters": {
                        "answers": "str",  # Optional. A value that specifies whether answers
                          should be returned as part of the search response. Known values are: "none"
                          and "extractive".
                        "captions": "str",  # Optional. A value that specifies whether
                          captions should be returned as part of the search response. Known values are:
                          "none" and "extractive".
                        "count": bool,  # Optional. A value that specifies whether to fetch
                          the total count of results. Default is false. Setting this value to true may
                          have a performance impact. Note that the count returned is an approximation.
                        "facets": [
                            "str"  # Optional. The list of facet expressions to apply to
                              the search query. Each facet expression contains a field name, optionally
                              followed by a comma-separated list of name:value pairs.
                        ],
                        "filter": "str",  # Optional. The OData $filter expression to apply
                          to the search query.
                        "highlight": "str",  # Optional. The comma-separated list of field
                          names to use for hit highlights. Only searchable fields can be used for hit
                          highlighting.
                        "highlightPostTag": "str",  # Optional. A string tag that is appended
                          to hit highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                        "highlightPreTag": "str",  # Optional. A string tag that is prepended
                          to hit highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                        "minimumCoverage": 0.0,  # Optional. A number between 0 and 100
                          indicating the percentage of the index that must be covered by a search query
                          in order for the query to be reported as a success. This parameter can be
                          useful for ensuring search availability even for services with only one
                          replica. The default is 100.
                        "orderby": "str",  # Optional. The comma-separated list of OData
                          $orderby expressions by which to sort the results. Each expression can be
                          either a field name or a call to either the geo.distance() or the
                          search.score() functions. Each expression can be followed by asc to indicate
                          ascending, or desc to indicate descending. The default is ascending order.
                          Ties will be broken by the match scores of documents. If no $orderby is
                          specified, the default sort order is descending by document match score.
                          There can be at most 32 $orderby clauses.
                        "queryType": "str",  # Optional. A value that specifies the syntax of
                          the search query. The default is 'simple'. Use 'full' if your query uses the
                          Lucene query syntax. Known values are: "simple", "full", and "semantic".
                        "scoringParameters": [
                            "str"  # Optional. The list of parameter values to be used in
                              scoring functions (for example, referencePointParameter) using the format
                              name-values. For example, if the scoring profile defines a function with
                              a parameter called 'mylocation' the parameter string would be
                              "mylocation--122.2,44.8" (without the quotes).
                        ],
                        "scoringProfile": "str",  # Optional. The name of a scoring profile
                          to evaluate match scores for matching documents in order to sort the results.
                        "scoringStatistics": "str",  # Optional. A value that specifies
                          whether we want to calculate scoring statistics (such as document frequency)
                          globally for more consistent scoring, or locally, for lower latency. The
                          default is 'local'. Use 'global' to aggregate scoring statistics globally
                          before scoring. Using global scoring statistics can increase latency of
                          search queries. Known values are: "local" and "global".
                        "search": "str",  # Optional. A full-text search query expression;
                          Use "*" or omit this parameter to match all documents.
                        "searchFields": "str",  # Optional. The comma-separated list of field
                          names to which to scope the full-text search. When using fielded search
                          (fieldName:searchExpression) in a full Lucene query, the field names of each
                          fielded search expression take precedence over any field names listed in this
                          parameter.
                        "searchMode": "str",  # Optional. A value that specifies whether any
                          or all of the search terms must be matched in order to count the document as
                          a match. Known values are: "any" and "all".
                        "select": "str",  # Optional. The comma-separated list of fields to
                          retrieve. If unspecified, all fields marked as retrievable in the schema are
                          included.
                        "semanticConfiguration": "str",  # Optional. The name of a semantic
                          configuration that will be used when processing documents for queries of type
                          semantic.
                        "semanticErrorHandling": "str",  # Optional. Allows the user to
                          choose whether a semantic call should fail completely (default / current
                          behavior), or to return partial results. Known values are: "partial" and
                          "fail".
                        "semanticMaxWaitInMilliseconds": 0,  # Optional. Allows the user to
                          set an upper bound on the amount of time it takes for semantic enrichment to
                          finish processing before the request fails.
                        "semanticQuery": "str",  # Optional. Allows setting a separate search
                          query that will be solely used for semantic reranking, semantic captions and
                          semantic answers. Is useful for scenarios where there is a need to use
                          different queries between the base retrieval and ranking phase, and the L2
                          semantic phase.
                        "sessionId": "str",  # Optional. A value to be used to create a
                          sticky session, which can help getting more consistent results. As long as
                          the same sessionId is used, a best-effort attempt will be made to target the
                          same replica set. Be wary that reusing the same sessionID values repeatedly
                          can interfere with the load balancing of the requests across replicas and
                          adversely affect the performance of the search service. The value used as
                          sessionId cannot start with a '_' character.
                        "skip": 0,  # Optional. The number of search results to skip. This
                          value cannot be greater than 100,000. If you need to scan documents in
                          sequence, but cannot use skip due to this limitation, consider using orderby
                          on a totally-ordered key and filter with a range query instead.
                        "top": 0,  # Optional. The number of search results to retrieve. This
                          can be used in conjunction with $skip to implement client-side paging of
                          search results. If results are truncated due to server-side paging, the
                          response will include a continuation token that can be used to issue another
                          Search request for the next page of results.
                        "vectorFilterMode": "str",  # Optional. Determines whether or not
                          filters are applied before or after the vector search is performed. Default
                          is 'preFilter' for new indexes. Known values are: "postFilter" and
                          "preFilter".
                        "vectorQueries": [
                            vector_query
                        ]
                    },
                    "@search.semanticPartialResponseReason": "str",  # Optional. Reason that a
                      partial response was returned for a semantic ranking request. Known values are:
                      "maxWaitExceeded", "capacityOverloaded", and "transient".
                    "@search.semanticPartialResponseType": "str"  # Optional. Type of partial
                      response that was returned for a semantic ranking request. Known values are:
                      "baseResults" and "rerankedResults".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchDocumentsResult] = kwargs.pop("cls", None)

        _request = build_documents_operations_search_get_request(
            index_name=index_name,
            search_text=search_text,
            include_total_result_count=include_total_result_count,
            facets=facets,
            _filter=_filter,
            highlight_fields=highlight_fields,
            highlight_post_tag=highlight_post_tag,
            highlight_pre_tag=highlight_pre_tag,
            minimum_coverage=minimum_coverage,
            order_by=order_by,
            query_type=query_type,
            scoring_parameters=scoring_parameters,
            scoring_profile=scoring_profile,
            search_fields=search_fields,
            search_mode=search_mode,
            scoring_statistics=scoring_statistics,
            session_id=session_id,
            _select=_select,
            _skip=_skip,
            _top=_top,
            semantic_configuration=semantic_configuration,
            semantic_error_handling=semantic_error_handling,
            semantic_max_wait_in_milliseconds=semantic_max_wait_in_milliseconds,
            answers=answers,
            captions=captions,
            semantic_query=semantic_query,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchDocumentsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def search_post(
        self,
        index_name: str,
        search_request: _models.SearchRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SearchDocumentsResult:
        # pylint: disable=line-too-long
        """Searches for documents in the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param search_request: The definition of the Search request. Required.
        :type search_request: ~azure.search.documents.models.SearchRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchDocumentsResult. The SearchDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                search_request = {
                    "answers": "str",  # Optional. A value that specifies whether answers should
                      be returned as part of the search response. Known values are: "none" and
                      "extractive".
                    "captions": "str",  # Optional. A value that specifies whether captions
                      should be returned as part of the search response. Known values are: "none" and
                      "extractive".
                    "count": bool,  # Optional. A value that specifies whether to fetch the total
                      count of results. Default is false. Setting this value to true may have a
                      performance impact. Note that the count returned is an approximation.
                    "facets": [
                        "str"  # Optional. The list of facet expressions to apply to the
                          search query. Each facet expression contains a field name, optionally
                          followed by a comma-separated list of name:value pairs.
                    ],
                    "filter": "str",  # Optional. The OData $filter expression to apply to the
                      search query.
                    "highlight": "str",  # Optional. The comma-separated list of field names to
                      use for hit highlights. Only searchable fields can be used for hit highlighting.
                    "highlightPostTag": "str",  # Optional. A string tag that is appended to hit
                      highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                    "highlightPreTag": "str",  # Optional. A string tag that is prepended to hit
                      highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                    "minimumCoverage": 0.0,  # Optional. A number between 0 and 100 indicating
                      the percentage of the index that must be covered by a search query in order for
                      the query to be reported as a success. This parameter can be useful for ensuring
                      search availability even for services with only one replica. The default is 100.
                    "orderby": "str",  # Optional. The comma-separated list of OData $orderby
                      expressions by which to sort the results. Each expression can be either a field
                      name or a call to either the geo.distance() or the search.score() functions. Each
                      expression can be followed by asc to indicate ascending, or desc to indicate
                      descending. The default is ascending order. Ties will be broken by the match
                      scores of documents. If no $orderby is specified, the default sort order is
                      descending by document match score. There can be at most 32 $orderby clauses.
                    "queryType": "str",  # Optional. A value that specifies the syntax of the
                      search query. The default is 'simple'. Use 'full' if your query uses the Lucene
                      query syntax. Known values are: "simple", "full", and "semantic".
                    "scoringParameters": [
                        "str"  # Optional. The list of parameter values to be used in scoring
                          functions (for example, referencePointParameter) using the format
                          name-values. For example, if the scoring profile defines a function with a
                          parameter called 'mylocation' the parameter string would be
                          "mylocation--122.2,44.8" (without the quotes).
                    ],
                    "scoringProfile": "str",  # Optional. The name of a scoring profile to
                      evaluate match scores for matching documents in order to sort the results.
                    "scoringStatistics": "str",  # Optional. A value that specifies whether we
                      want to calculate scoring statistics (such as document frequency) globally for
                      more consistent scoring, or locally, for lower latency. The default is 'local'.
                      Use 'global' to aggregate scoring statistics globally before scoring. Using
                      global scoring statistics can increase latency of search queries. Known values
                      are: "local" and "global".
                    "search": "str",  # Optional. A full-text search query expression; Use "*" or
                      omit this parameter to match all documents.
                    "searchFields": "str",  # Optional. The comma-separated list of field names
                      to which to scope the full-text search. When using fielded search
                      (fieldName:searchExpression) in a full Lucene query, the field names of each
                      fielded search expression take precedence over any field names listed in this
                      parameter.
                    "searchMode": "str",  # Optional. A value that specifies whether any or all
                      of the search terms must be matched in order to count the document as a match.
                      Known values are: "any" and "all".
                    "select": "str",  # Optional. The comma-separated list of fields to retrieve.
                      If unspecified, all fields marked as retrievable in the schema are included.
                    "semanticConfiguration": "str",  # Optional. The name of a semantic
                      configuration that will be used when processing documents for queries of type
                      semantic.
                    "semanticErrorHandling": "str",  # Optional. Allows the user to choose
                      whether a semantic call should fail completely (default / current behavior), or
                      to return partial results. Known values are: "partial" and "fail".
                    "semanticMaxWaitInMilliseconds": 0,  # Optional. Allows the user to set an
                      upper bound on the amount of time it takes for semantic enrichment to finish
                      processing before the request fails.
                    "semanticQuery": "str",  # Optional. Allows setting a separate search query
                      that will be solely used for semantic reranking, semantic captions and semantic
                      answers. Is useful for scenarios where there is a need to use different queries
                      between the base retrieval and ranking phase, and the L2 semantic phase.
                    "sessionId": "str",  # Optional. A value to be used to create a sticky
                      session, which can help getting more consistent results. As long as the same
                      sessionId is used, a best-effort attempt will be made to target the same replica
                      set. Be wary that reusing the same sessionID values repeatedly can interfere with
                      the load balancing of the requests across replicas and adversely affect the
                      performance of the search service. The value used as sessionId cannot start with
                      a '_' character.
                    "skip": 0,  # Optional. The number of search results to skip. This value
                      cannot be greater than 100,000. If you need to scan documents in sequence, but
                      cannot use skip due to this limitation, consider using orderby on a
                      totally-ordered key and filter with a range query instead.
                    "top": 0,  # Optional. The number of search results to retrieve. This can be
                      used in conjunction with $skip to implement client-side paging of search results.
                      If results are truncated due to server-side paging, the response will include a
                      continuation token that can be used to issue another Search request for the next
                      page of results.
                    "vectorFilterMode": "str",  # Optional. Determines whether or not filters are
                      applied before or after the vector search is performed. Default is 'preFilter'
                      for new indexes. Known values are: "postFilter" and "preFilter".
                    "vectorQueries": [
                        vector_query
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.score": 0.0,  # The relevance score of the document
                              compared to other documents returned by the query. Required.
                            "@search.captions": [
                                {
                                    "highlights": "str",  # Optional. Same text
                                      passage as in the Text property with highlighted phrases most
                                      relevant to the query.
                                    "text": "str"  # Optional. A representative
                                      text passage extracted from the document most relevant to the
                                      search query.
                                }
                            ],
                            "@search.highlights": {
                                "str": [
                                    "str"  # Optional. Text fragments from the
                                      document that indicate the matching search terms, organized by
                                      each applicable field; null if hit highlighting was not enabled
                                      for the query.
                                ]
                            },
                            "@search.rerankerScore": 0.0  # Optional. The relevance score
                              computed by the semantic ranker for the top search results. Search
                              results are sorted by the RerankerScore first and then by the Score.
                              RerankerScore is only returned for queries of type 'semantic'.
                        }
                    ],
                    "@odata.count": 0,  # Optional. The total count of results found by the
                      search operation, or null if the count was not requested. If present, the count
                      may be greater than the number of results in this response. This can happen if
                      you use the $top or $skip parameters, or if the query can't return all the
                      requested documents in a single response.
                    "@odata.nextLink": "str",  # Optional. Continuation URL returned when the
                      query can't return all the requested results in a single response. You can use
                      this URL to formulate another GET or POST Search request to get the next part of
                      the search response. Make sure to use the same verb (GET or POST) as the request
                      that produced this response.
                    "@search.answers": [
                        {
                            "highlights": "str",  # Optional. Same text passage as in the
                              Text property with highlighted text phrases most relevant to the query.
                            "key": "str",  # Optional. The key of the document the answer
                              was extracted from.
                            "score": 0.0,  # Optional. The score value represents how
                              relevant the answer is to the query relative to other answers returned
                              for the query.
                            "text": "str"  # Optional. The text passage extracted from
                              the document contents as the answer.
                        }
                    ],
                    "@search.coverage": 0.0,  # Optional. A value indicating the percentage of
                      the index that was included in the query, or null if minimumCoverage was not
                      specified in the request.
                    "@search.facets": {
                        "str": [
                            {
                                "count": 0  # Optional. The approximate count of
                                  documents falling within the bucket described by this facet.
                            }
                        ]
                    },
                    "@search.nextPageParameters": {
                        "answers": "str",  # Optional. A value that specifies whether answers
                          should be returned as part of the search response. Known values are: "none"
                          and "extractive".
                        "captions": "str",  # Optional. A value that specifies whether
                          captions should be returned as part of the search response. Known values are:
                          "none" and "extractive".
                        "count": bool,  # Optional. A value that specifies whether to fetch
                          the total count of results. Default is false. Setting this value to true may
                          have a performance impact. Note that the count returned is an approximation.
                        "facets": [
                            "str"  # Optional. The list of facet expressions to apply to
                              the search query. Each facet expression contains a field name, optionally
                              followed by a comma-separated list of name:value pairs.
                        ],
                        "filter": "str",  # Optional. The OData $filter expression to apply
                          to the search query.
                        "highlight": "str",  # Optional. The comma-separated list of field
                          names to use for hit highlights. Only searchable fields can be used for hit
                          highlighting.
                        "highlightPostTag": "str",  # Optional. A string tag that is appended
                          to hit highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                        "highlightPreTag": "str",  # Optional. A string tag that is prepended
                          to hit highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                        "minimumCoverage": 0.0,  # Optional. A number between 0 and 100
                          indicating the percentage of the index that must be covered by a search query
                          in order for the query to be reported as a success. This parameter can be
                          useful for ensuring search availability even for services with only one
                          replica. The default is 100.
                        "orderby": "str",  # Optional. The comma-separated list of OData
                          $orderby expressions by which to sort the results. Each expression can be
                          either a field name or a call to either the geo.distance() or the
                          search.score() functions. Each expression can be followed by asc to indicate
                          ascending, or desc to indicate descending. The default is ascending order.
                          Ties will be broken by the match scores of documents. If no $orderby is
                          specified, the default sort order is descending by document match score.
                          There can be at most 32 $orderby clauses.
                        "queryType": "str",  # Optional. A value that specifies the syntax of
                          the search query. The default is 'simple'. Use 'full' if your query uses the
                          Lucene query syntax. Known values are: "simple", "full", and "semantic".
                        "scoringParameters": [
                            "str"  # Optional. The list of parameter values to be used in
                              scoring functions (for example, referencePointParameter) using the format
                              name-values. For example, if the scoring profile defines a function with
                              a parameter called 'mylocation' the parameter string would be
                              "mylocation--122.2,44.8" (without the quotes).
                        ],
                        "scoringProfile": "str",  # Optional. The name of a scoring profile
                          to evaluate match scores for matching documents in order to sort the results.
                        "scoringStatistics": "str",  # Optional. A value that specifies
                          whether we want to calculate scoring statistics (such as document frequency)
                          globally for more consistent scoring, or locally, for lower latency. The
                          default is 'local'. Use 'global' to aggregate scoring statistics globally
                          before scoring. Using global scoring statistics can increase latency of
                          search queries. Known values are: "local" and "global".
                        "search": "str",  # Optional. A full-text search query expression;
                          Use "*" or omit this parameter to match all documents.
                        "searchFields": "str",  # Optional. The comma-separated list of field
                          names to which to scope the full-text search. When using fielded search
                          (fieldName:searchExpression) in a full Lucene query, the field names of each
                          fielded search expression take precedence over any field names listed in this
                          parameter.
                        "searchMode": "str",  # Optional. A value that specifies whether any
                          or all of the search terms must be matched in order to count the document as
                          a match. Known values are: "any" and "all".
                        "select": "str",  # Optional. The comma-separated list of fields to
                          retrieve. If unspecified, all fields marked as retrievable in the schema are
                          included.
                        "semanticConfiguration": "str",  # Optional. The name of a semantic
                          configuration that will be used when processing documents for queries of type
                          semantic.
                        "semanticErrorHandling": "str",  # Optional. Allows the user to
                          choose whether a semantic call should fail completely (default / current
                          behavior), or to return partial results. Known values are: "partial" and
                          "fail".
                        "semanticMaxWaitInMilliseconds": 0,  # Optional. Allows the user to
                          set an upper bound on the amount of time it takes for semantic enrichment to
                          finish processing before the request fails.
                        "semanticQuery": "str",  # Optional. Allows setting a separate search
                          query that will be solely used for semantic reranking, semantic captions and
                          semantic answers. Is useful for scenarios where there is a need to use
                          different queries between the base retrieval and ranking phase, and the L2
                          semantic phase.
                        "sessionId": "str",  # Optional. A value to be used to create a
                          sticky session, which can help getting more consistent results. As long as
                          the same sessionId is used, a best-effort attempt will be made to target the
                          same replica set. Be wary that reusing the same sessionID values repeatedly
                          can interfere with the load balancing of the requests across replicas and
                          adversely affect the performance of the search service. The value used as
                          sessionId cannot start with a '_' character.
                        "skip": 0,  # Optional. The number of search results to skip. This
                          value cannot be greater than 100,000. If you need to scan documents in
                          sequence, but cannot use skip due to this limitation, consider using orderby
                          on a totally-ordered key and filter with a range query instead.
                        "top": 0,  # Optional. The number of search results to retrieve. This
                          can be used in conjunction with $skip to implement client-side paging of
                          search results. If results are truncated due to server-side paging, the
                          response will include a continuation token that can be used to issue another
                          Search request for the next page of results.
                        "vectorFilterMode": "str",  # Optional. Determines whether or not
                          filters are applied before or after the vector search is performed. Default
                          is 'preFilter' for new indexes. Known values are: "postFilter" and
                          "preFilter".
                        "vectorQueries": [
                            vector_query
                        ]
                    },
                    "@search.semanticPartialResponseReason": "str",  # Optional. Reason that a
                      partial response was returned for a semantic ranking request. Known values are:
                      "maxWaitExceeded", "capacityOverloaded", and "transient".
                    "@search.semanticPartialResponseType": "str"  # Optional. Type of partial
                      response that was returned for a semantic ranking request. Known values are:
                      "baseResults" and "rerankedResults".
                }
        """

    @overload
    async def search_post(
        self, index_name: str, search_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchDocumentsResult:
        # pylint: disable=line-too-long
        """Searches for documents in the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param search_request: The definition of the Search request. Required.
        :type search_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchDocumentsResult. The SearchDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.score": 0.0,  # The relevance score of the document
                              compared to other documents returned by the query. Required.
                            "@search.captions": [
                                {
                                    "highlights": "str",  # Optional. Same text
                                      passage as in the Text property with highlighted phrases most
                                      relevant to the query.
                                    "text": "str"  # Optional. A representative
                                      text passage extracted from the document most relevant to the
                                      search query.
                                }
                            ],
                            "@search.highlights": {
                                "str": [
                                    "str"  # Optional. Text fragments from the
                                      document that indicate the matching search terms, organized by
                                      each applicable field; null if hit highlighting was not enabled
                                      for the query.
                                ]
                            },
                            "@search.rerankerScore": 0.0  # Optional. The relevance score
                              computed by the semantic ranker for the top search results. Search
                              results are sorted by the RerankerScore first and then by the Score.
                              RerankerScore is only returned for queries of type 'semantic'.
                        }
                    ],
                    "@odata.count": 0,  # Optional. The total count of results found by the
                      search operation, or null if the count was not requested. If present, the count
                      may be greater than the number of results in this response. This can happen if
                      you use the $top or $skip parameters, or if the query can't return all the
                      requested documents in a single response.
                    "@odata.nextLink": "str",  # Optional. Continuation URL returned when the
                      query can't return all the requested results in a single response. You can use
                      this URL to formulate another GET or POST Search request to get the next part of
                      the search response. Make sure to use the same verb (GET or POST) as the request
                      that produced this response.
                    "@search.answers": [
                        {
                            "highlights": "str",  # Optional. Same text passage as in the
                              Text property with highlighted text phrases most relevant to the query.
                            "key": "str",  # Optional. The key of the document the answer
                              was extracted from.
                            "score": 0.0,  # Optional. The score value represents how
                              relevant the answer is to the query relative to other answers returned
                              for the query.
                            "text": "str"  # Optional. The text passage extracted from
                              the document contents as the answer.
                        }
                    ],
                    "@search.coverage": 0.0,  # Optional. A value indicating the percentage of
                      the index that was included in the query, or null if minimumCoverage was not
                      specified in the request.
                    "@search.facets": {
                        "str": [
                            {
                                "count": 0  # Optional. The approximate count of
                                  documents falling within the bucket described by this facet.
                            }
                        ]
                    },
                    "@search.nextPageParameters": {
                        "answers": "str",  # Optional. A value that specifies whether answers
                          should be returned as part of the search response. Known values are: "none"
                          and "extractive".
                        "captions": "str",  # Optional. A value that specifies whether
                          captions should be returned as part of the search response. Known values are:
                          "none" and "extractive".
                        "count": bool,  # Optional. A value that specifies whether to fetch
                          the total count of results. Default is false. Setting this value to true may
                          have a performance impact. Note that the count returned is an approximation.
                        "facets": [
                            "str"  # Optional. The list of facet expressions to apply to
                              the search query. Each facet expression contains a field name, optionally
                              followed by a comma-separated list of name:value pairs.
                        ],
                        "filter": "str",  # Optional. The OData $filter expression to apply
                          to the search query.
                        "highlight": "str",  # Optional. The comma-separated list of field
                          names to use for hit highlights. Only searchable fields can be used for hit
                          highlighting.
                        "highlightPostTag": "str",  # Optional. A string tag that is appended
                          to hit highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                        "highlightPreTag": "str",  # Optional. A string tag that is prepended
                          to hit highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                        "minimumCoverage": 0.0,  # Optional. A number between 0 and 100
                          indicating the percentage of the index that must be covered by a search query
                          in order for the query to be reported as a success. This parameter can be
                          useful for ensuring search availability even for services with only one
                          replica. The default is 100.
                        "orderby": "str",  # Optional. The comma-separated list of OData
                          $orderby expressions by which to sort the results. Each expression can be
                          either a field name or a call to either the geo.distance() or the
                          search.score() functions. Each expression can be followed by asc to indicate
                          ascending, or desc to indicate descending. The default is ascending order.
                          Ties will be broken by the match scores of documents. If no $orderby is
                          specified, the default sort order is descending by document match score.
                          There can be at most 32 $orderby clauses.
                        "queryType": "str",  # Optional. A value that specifies the syntax of
                          the search query. The default is 'simple'. Use 'full' if your query uses the
                          Lucene query syntax. Known values are: "simple", "full", and "semantic".
                        "scoringParameters": [
                            "str"  # Optional. The list of parameter values to be used in
                              scoring functions (for example, referencePointParameter) using the format
                              name-values. For example, if the scoring profile defines a function with
                              a parameter called 'mylocation' the parameter string would be
                              "mylocation--122.2,44.8" (without the quotes).
                        ],
                        "scoringProfile": "str",  # Optional. The name of a scoring profile
                          to evaluate match scores for matching documents in order to sort the results.
                        "scoringStatistics": "str",  # Optional. A value that specifies
                          whether we want to calculate scoring statistics (such as document frequency)
                          globally for more consistent scoring, or locally, for lower latency. The
                          default is 'local'. Use 'global' to aggregate scoring statistics globally
                          before scoring. Using global scoring statistics can increase latency of
                          search queries. Known values are: "local" and "global".
                        "search": "str",  # Optional. A full-text search query expression;
                          Use "*" or omit this parameter to match all documents.
                        "searchFields": "str",  # Optional. The comma-separated list of field
                          names to which to scope the full-text search. When using fielded search
                          (fieldName:searchExpression) in a full Lucene query, the field names of each
                          fielded search expression take precedence over any field names listed in this
                          parameter.
                        "searchMode": "str",  # Optional. A value that specifies whether any
                          or all of the search terms must be matched in order to count the document as
                          a match. Known values are: "any" and "all".
                        "select": "str",  # Optional. The comma-separated list of fields to
                          retrieve. If unspecified, all fields marked as retrievable in the schema are
                          included.
                        "semanticConfiguration": "str",  # Optional. The name of a semantic
                          configuration that will be used when processing documents for queries of type
                          semantic.
                        "semanticErrorHandling": "str",  # Optional. Allows the user to
                          choose whether a semantic call should fail completely (default / current
                          behavior), or to return partial results. Known values are: "partial" and
                          "fail".
                        "semanticMaxWaitInMilliseconds": 0,  # Optional. Allows the user to
                          set an upper bound on the amount of time it takes for semantic enrichment to
                          finish processing before the request fails.
                        "semanticQuery": "str",  # Optional. Allows setting a separate search
                          query that will be solely used for semantic reranking, semantic captions and
                          semantic answers. Is useful for scenarios where there is a need to use
                          different queries between the base retrieval and ranking phase, and the L2
                          semantic phase.
                        "sessionId": "str",  # Optional. A value to be used to create a
                          sticky session, which can help getting more consistent results. As long as
                          the same sessionId is used, a best-effort attempt will be made to target the
                          same replica set. Be wary that reusing the same sessionID values repeatedly
                          can interfere with the load balancing of the requests across replicas and
                          adversely affect the performance of the search service. The value used as
                          sessionId cannot start with a '_' character.
                        "skip": 0,  # Optional. The number of search results to skip. This
                          value cannot be greater than 100,000. If you need to scan documents in
                          sequence, but cannot use skip due to this limitation, consider using orderby
                          on a totally-ordered key and filter with a range query instead.
                        "top": 0,  # Optional. The number of search results to retrieve. This
                          can be used in conjunction with $skip to implement client-side paging of
                          search results. If results are truncated due to server-side paging, the
                          response will include a continuation token that can be used to issue another
                          Search request for the next page of results.
                        "vectorFilterMode": "str",  # Optional. Determines whether or not
                          filters are applied before or after the vector search is performed. Default
                          is 'preFilter' for new indexes. Known values are: "postFilter" and
                          "preFilter".
                        "vectorQueries": [
                            vector_query
                        ]
                    },
                    "@search.semanticPartialResponseReason": "str",  # Optional. Reason that a
                      partial response was returned for a semantic ranking request. Known values are:
                      "maxWaitExceeded", "capacityOverloaded", and "transient".
                    "@search.semanticPartialResponseType": "str"  # Optional. Type of partial
                      response that was returned for a semantic ranking request. Known values are:
                      "baseResults" and "rerankedResults".
                }
        """

    @overload
    async def search_post(
        self, index_name: str, search_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchDocumentsResult:
        # pylint: disable=line-too-long
        """Searches for documents in the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param search_request: The definition of the Search request. Required.
        :type search_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchDocumentsResult. The SearchDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.score": 0.0,  # The relevance score of the document
                              compared to other documents returned by the query. Required.
                            "@search.captions": [
                                {
                                    "highlights": "str",  # Optional. Same text
                                      passage as in the Text property with highlighted phrases most
                                      relevant to the query.
                                    "text": "str"  # Optional. A representative
                                      text passage extracted from the document most relevant to the
                                      search query.
                                }
                            ],
                            "@search.highlights": {
                                "str": [
                                    "str"  # Optional. Text fragments from the
                                      document that indicate the matching search terms, organized by
                                      each applicable field; null if hit highlighting was not enabled
                                      for the query.
                                ]
                            },
                            "@search.rerankerScore": 0.0  # Optional. The relevance score
                              computed by the semantic ranker for the top search results. Search
                              results are sorted by the RerankerScore first and then by the Score.
                              RerankerScore is only returned for queries of type 'semantic'.
                        }
                    ],
                    "@odata.count": 0,  # Optional. The total count of results found by the
                      search operation, or null if the count was not requested. If present, the count
                      may be greater than the number of results in this response. This can happen if
                      you use the $top or $skip parameters, or if the query can't return all the
                      requested documents in a single response.
                    "@odata.nextLink": "str",  # Optional. Continuation URL returned when the
                      query can't return all the requested results in a single response. You can use
                      this URL to formulate another GET or POST Search request to get the next part of
                      the search response. Make sure to use the same verb (GET or POST) as the request
                      that produced this response.
                    "@search.answers": [
                        {
                            "highlights": "str",  # Optional. Same text passage as in the
                              Text property with highlighted text phrases most relevant to the query.
                            "key": "str",  # Optional. The key of the document the answer
                              was extracted from.
                            "score": 0.0,  # Optional. The score value represents how
                              relevant the answer is to the query relative to other answers returned
                              for the query.
                            "text": "str"  # Optional. The text passage extracted from
                              the document contents as the answer.
                        }
                    ],
                    "@search.coverage": 0.0,  # Optional. A value indicating the percentage of
                      the index that was included in the query, or null if minimumCoverage was not
                      specified in the request.
                    "@search.facets": {
                        "str": [
                            {
                                "count": 0  # Optional. The approximate count of
                                  documents falling within the bucket described by this facet.
                            }
                        ]
                    },
                    "@search.nextPageParameters": {
                        "answers": "str",  # Optional. A value that specifies whether answers
                          should be returned as part of the search response. Known values are: "none"
                          and "extractive".
                        "captions": "str",  # Optional. A value that specifies whether
                          captions should be returned as part of the search response. Known values are:
                          "none" and "extractive".
                        "count": bool,  # Optional. A value that specifies whether to fetch
                          the total count of results. Default is false. Setting this value to true may
                          have a performance impact. Note that the count returned is an approximation.
                        "facets": [
                            "str"  # Optional. The list of facet expressions to apply to
                              the search query. Each facet expression contains a field name, optionally
                              followed by a comma-separated list of name:value pairs.
                        ],
                        "filter": "str",  # Optional. The OData $filter expression to apply
                          to the search query.
                        "highlight": "str",  # Optional. The comma-separated list of field
                          names to use for hit highlights. Only searchable fields can be used for hit
                          highlighting.
                        "highlightPostTag": "str",  # Optional. A string tag that is appended
                          to hit highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                        "highlightPreTag": "str",  # Optional. A string tag that is prepended
                          to hit highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                        "minimumCoverage": 0.0,  # Optional. A number between 0 and 100
                          indicating the percentage of the index that must be covered by a search query
                          in order for the query to be reported as a success. This parameter can be
                          useful for ensuring search availability even for services with only one
                          replica. The default is 100.
                        "orderby": "str",  # Optional. The comma-separated list of OData
                          $orderby expressions by which to sort the results. Each expression can be
                          either a field name or a call to either the geo.distance() or the
                          search.score() functions. Each expression can be followed by asc to indicate
                          ascending, or desc to indicate descending. The default is ascending order.
                          Ties will be broken by the match scores of documents. If no $orderby is
                          specified, the default sort order is descending by document match score.
                          There can be at most 32 $orderby clauses.
                        "queryType": "str",  # Optional. A value that specifies the syntax of
                          the search query. The default is 'simple'. Use 'full' if your query uses the
                          Lucene query syntax. Known values are: "simple", "full", and "semantic".
                        "scoringParameters": [
                            "str"  # Optional. The list of parameter values to be used in
                              scoring functions (for example, referencePointParameter) using the format
                              name-values. For example, if the scoring profile defines a function with
                              a parameter called 'mylocation' the parameter string would be
                              "mylocation--122.2,44.8" (without the quotes).
                        ],
                        "scoringProfile": "str",  # Optional. The name of a scoring profile
                          to evaluate match scores for matching documents in order to sort the results.
                        "scoringStatistics": "str",  # Optional. A value that specifies
                          whether we want to calculate scoring statistics (such as document frequency)
                          globally for more consistent scoring, or locally, for lower latency. The
                          default is 'local'. Use 'global' to aggregate scoring statistics globally
                          before scoring. Using global scoring statistics can increase latency of
                          search queries. Known values are: "local" and "global".
                        "search": "str",  # Optional. A full-text search query expression;
                          Use "*" or omit this parameter to match all documents.
                        "searchFields": "str",  # Optional. The comma-separated list of field
                          names to which to scope the full-text search. When using fielded search
                          (fieldName:searchExpression) in a full Lucene query, the field names of each
                          fielded search expression take precedence over any field names listed in this
                          parameter.
                        "searchMode": "str",  # Optional. A value that specifies whether any
                          or all of the search terms must be matched in order to count the document as
                          a match. Known values are: "any" and "all".
                        "select": "str",  # Optional. The comma-separated list of fields to
                          retrieve. If unspecified, all fields marked as retrievable in the schema are
                          included.
                        "semanticConfiguration": "str",  # Optional. The name of a semantic
                          configuration that will be used when processing documents for queries of type
                          semantic.
                        "semanticErrorHandling": "str",  # Optional. Allows the user to
                          choose whether a semantic call should fail completely (default / current
                          behavior), or to return partial results. Known values are: "partial" and
                          "fail".
                        "semanticMaxWaitInMilliseconds": 0,  # Optional. Allows the user to
                          set an upper bound on the amount of time it takes for semantic enrichment to
                          finish processing before the request fails.
                        "semanticQuery": "str",  # Optional. Allows setting a separate search
                          query that will be solely used for semantic reranking, semantic captions and
                          semantic answers. Is useful for scenarios where there is a need to use
                          different queries between the base retrieval and ranking phase, and the L2
                          semantic phase.
                        "sessionId": "str",  # Optional. A value to be used to create a
                          sticky session, which can help getting more consistent results. As long as
                          the same sessionId is used, a best-effort attempt will be made to target the
                          same replica set. Be wary that reusing the same sessionID values repeatedly
                          can interfere with the load balancing of the requests across replicas and
                          adversely affect the performance of the search service. The value used as
                          sessionId cannot start with a '_' character.
                        "skip": 0,  # Optional. The number of search results to skip. This
                          value cannot be greater than 100,000. If you need to scan documents in
                          sequence, but cannot use skip due to this limitation, consider using orderby
                          on a totally-ordered key and filter with a range query instead.
                        "top": 0,  # Optional. The number of search results to retrieve. This
                          can be used in conjunction with $skip to implement client-side paging of
                          search results. If results are truncated due to server-side paging, the
                          response will include a continuation token that can be used to issue another
                          Search request for the next page of results.
                        "vectorFilterMode": "str",  # Optional. Determines whether or not
                          filters are applied before or after the vector search is performed. Default
                          is 'preFilter' for new indexes. Known values are: "postFilter" and
                          "preFilter".
                        "vectorQueries": [
                            vector_query
                        ]
                    },
                    "@search.semanticPartialResponseReason": "str",  # Optional. Reason that a
                      partial response was returned for a semantic ranking request. Known values are:
                      "maxWaitExceeded", "capacityOverloaded", and "transient".
                    "@search.semanticPartialResponseType": "str"  # Optional. Type of partial
                      response that was returned for a semantic ranking request. Known values are:
                      "baseResults" and "rerankedResults".
                }
        """

    @distributed_trace_async
    async def search_post(
        self, index_name: str, search_request: Union[_models.SearchRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SearchDocumentsResult:
        # pylint: disable=line-too-long
        """Searches for documents in the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param search_request: The definition of the Search request. Is one of the following types:
         SearchRequest, JSON, IO[bytes] Required.
        :type search_request: ~azure.search.documents.models.SearchRequest or JSON or IO[bytes]
        :return: SearchDocumentsResult. The SearchDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                search_request = {
                    "answers": "str",  # Optional. A value that specifies whether answers should
                      be returned as part of the search response. Known values are: "none" and
                      "extractive".
                    "captions": "str",  # Optional. A value that specifies whether captions
                      should be returned as part of the search response. Known values are: "none" and
                      "extractive".
                    "count": bool,  # Optional. A value that specifies whether to fetch the total
                      count of results. Default is false. Setting this value to true may have a
                      performance impact. Note that the count returned is an approximation.
                    "facets": [
                        "str"  # Optional. The list of facet expressions to apply to the
                          search query. Each facet expression contains a field name, optionally
                          followed by a comma-separated list of name:value pairs.
                    ],
                    "filter": "str",  # Optional. The OData $filter expression to apply to the
                      search query.
                    "highlight": "str",  # Optional. The comma-separated list of field names to
                      use for hit highlights. Only searchable fields can be used for hit highlighting.
                    "highlightPostTag": "str",  # Optional. A string tag that is appended to hit
                      highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                    "highlightPreTag": "str",  # Optional. A string tag that is prepended to hit
                      highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                    "minimumCoverage": 0.0,  # Optional. A number between 0 and 100 indicating
                      the percentage of the index that must be covered by a search query in order for
                      the query to be reported as a success. This parameter can be useful for ensuring
                      search availability even for services with only one replica. The default is 100.
                    "orderby": "str",  # Optional. The comma-separated list of OData $orderby
                      expressions by which to sort the results. Each expression can be either a field
                      name or a call to either the geo.distance() or the search.score() functions. Each
                      expression can be followed by asc to indicate ascending, or desc to indicate
                      descending. The default is ascending order. Ties will be broken by the match
                      scores of documents. If no $orderby is specified, the default sort order is
                      descending by document match score. There can be at most 32 $orderby clauses.
                    "queryType": "str",  # Optional. A value that specifies the syntax of the
                      search query. The default is 'simple'. Use 'full' if your query uses the Lucene
                      query syntax. Known values are: "simple", "full", and "semantic".
                    "scoringParameters": [
                        "str"  # Optional. The list of parameter values to be used in scoring
                          functions (for example, referencePointParameter) using the format
                          name-values. For example, if the scoring profile defines a function with a
                          parameter called 'mylocation' the parameter string would be
                          "mylocation--122.2,44.8" (without the quotes).
                    ],
                    "scoringProfile": "str",  # Optional. The name of a scoring profile to
                      evaluate match scores for matching documents in order to sort the results.
                    "scoringStatistics": "str",  # Optional. A value that specifies whether we
                      want to calculate scoring statistics (such as document frequency) globally for
                      more consistent scoring, or locally, for lower latency. The default is 'local'.
                      Use 'global' to aggregate scoring statistics globally before scoring. Using
                      global scoring statistics can increase latency of search queries. Known values
                      are: "local" and "global".
                    "search": "str",  # Optional. A full-text search query expression; Use "*" or
                      omit this parameter to match all documents.
                    "searchFields": "str",  # Optional. The comma-separated list of field names
                      to which to scope the full-text search. When using fielded search
                      (fieldName:searchExpression) in a full Lucene query, the field names of each
                      fielded search expression take precedence over any field names listed in this
                      parameter.
                    "searchMode": "str",  # Optional. A value that specifies whether any or all
                      of the search terms must be matched in order to count the document as a match.
                      Known values are: "any" and "all".
                    "select": "str",  # Optional. The comma-separated list of fields to retrieve.
                      If unspecified, all fields marked as retrievable in the schema are included.
                    "semanticConfiguration": "str",  # Optional. The name of a semantic
                      configuration that will be used when processing documents for queries of type
                      semantic.
                    "semanticErrorHandling": "str",  # Optional. Allows the user to choose
                      whether a semantic call should fail completely (default / current behavior), or
                      to return partial results. Known values are: "partial" and "fail".
                    "semanticMaxWaitInMilliseconds": 0,  # Optional. Allows the user to set an
                      upper bound on the amount of time it takes for semantic enrichment to finish
                      processing before the request fails.
                    "semanticQuery": "str",  # Optional. Allows setting a separate search query
                      that will be solely used for semantic reranking, semantic captions and semantic
                      answers. Is useful for scenarios where there is a need to use different queries
                      between the base retrieval and ranking phase, and the L2 semantic phase.
                    "sessionId": "str",  # Optional. A value to be used to create a sticky
                      session, which can help getting more consistent results. As long as the same
                      sessionId is used, a best-effort attempt will be made to target the same replica
                      set. Be wary that reusing the same sessionID values repeatedly can interfere with
                      the load balancing of the requests across replicas and adversely affect the
                      performance of the search service. The value used as sessionId cannot start with
                      a '_' character.
                    "skip": 0,  # Optional. The number of search results to skip. This value
                      cannot be greater than 100,000. If you need to scan documents in sequence, but
                      cannot use skip due to this limitation, consider using orderby on a
                      totally-ordered key and filter with a range query instead.
                    "top": 0,  # Optional. The number of search results to retrieve. This can be
                      used in conjunction with $skip to implement client-side paging of search results.
                      If results are truncated due to server-side paging, the response will include a
                      continuation token that can be used to issue another Search request for the next
                      page of results.
                    "vectorFilterMode": "str",  # Optional. Determines whether or not filters are
                      applied before or after the vector search is performed. Default is 'preFilter'
                      for new indexes. Known values are: "postFilter" and "preFilter".
                    "vectorQueries": [
                        vector_query
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.score": 0.0,  # The relevance score of the document
                              compared to other documents returned by the query. Required.
                            "@search.captions": [
                                {
                                    "highlights": "str",  # Optional. Same text
                                      passage as in the Text property with highlighted phrases most
                                      relevant to the query.
                                    "text": "str"  # Optional. A representative
                                      text passage extracted from the document most relevant to the
                                      search query.
                                }
                            ],
                            "@search.highlights": {
                                "str": [
                                    "str"  # Optional. Text fragments from the
                                      document that indicate the matching search terms, organized by
                                      each applicable field; null if hit highlighting was not enabled
                                      for the query.
                                ]
                            },
                            "@search.rerankerScore": 0.0  # Optional. The relevance score
                              computed by the semantic ranker for the top search results. Search
                              results are sorted by the RerankerScore first and then by the Score.
                              RerankerScore is only returned for queries of type 'semantic'.
                        }
                    ],
                    "@odata.count": 0,  # Optional. The total count of results found by the
                      search operation, or null if the count was not requested. If present, the count
                      may be greater than the number of results in this response. This can happen if
                      you use the $top or $skip parameters, or if the query can't return all the
                      requested documents in a single response.
                    "@odata.nextLink": "str",  # Optional. Continuation URL returned when the
                      query can't return all the requested results in a single response. You can use
                      this URL to formulate another GET or POST Search request to get the next part of
                      the search response. Make sure to use the same verb (GET or POST) as the request
                      that produced this response.
                    "@search.answers": [
                        {
                            "highlights": "str",  # Optional. Same text passage as in the
                              Text property with highlighted text phrases most relevant to the query.
                            "key": "str",  # Optional. The key of the document the answer
                              was extracted from.
                            "score": 0.0,  # Optional. The score value represents how
                              relevant the answer is to the query relative to other answers returned
                              for the query.
                            "text": "str"  # Optional. The text passage extracted from
                              the document contents as the answer.
                        }
                    ],
                    "@search.coverage": 0.0,  # Optional. A value indicating the percentage of
                      the index that was included in the query, or null if minimumCoverage was not
                      specified in the request.
                    "@search.facets": {
                        "str": [
                            {
                                "count": 0  # Optional. The approximate count of
                                  documents falling within the bucket described by this facet.
                            }
                        ]
                    },
                    "@search.nextPageParameters": {
                        "answers": "str",  # Optional. A value that specifies whether answers
                          should be returned as part of the search response. Known values are: "none"
                          and "extractive".
                        "captions": "str",  # Optional. A value that specifies whether
                          captions should be returned as part of the search response. Known values are:
                          "none" and "extractive".
                        "count": bool,  # Optional. A value that specifies whether to fetch
                          the total count of results. Default is false. Setting this value to true may
                          have a performance impact. Note that the count returned is an approximation.
                        "facets": [
                            "str"  # Optional. The list of facet expressions to apply to
                              the search query. Each facet expression contains a field name, optionally
                              followed by a comma-separated list of name:value pairs.
                        ],
                        "filter": "str",  # Optional. The OData $filter expression to apply
                          to the search query.
                        "highlight": "str",  # Optional. The comma-separated list of field
                          names to use for hit highlights. Only searchable fields can be used for hit
                          highlighting.
                        "highlightPostTag": "str",  # Optional. A string tag that is appended
                          to hit highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                        "highlightPreTag": "str",  # Optional. A string tag that is prepended
                          to hit highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                        "minimumCoverage": 0.0,  # Optional. A number between 0 and 100
                          indicating the percentage of the index that must be covered by a search query
                          in order for the query to be reported as a success. This parameter can be
                          useful for ensuring search availability even for services with only one
                          replica. The default is 100.
                        "orderby": "str",  # Optional. The comma-separated list of OData
                          $orderby expressions by which to sort the results. Each expression can be
                          either a field name or a call to either the geo.distance() or the
                          search.score() functions. Each expression can be followed by asc to indicate
                          ascending, or desc to indicate descending. The default is ascending order.
                          Ties will be broken by the match scores of documents. If no $orderby is
                          specified, the default sort order is descending by document match score.
                          There can be at most 32 $orderby clauses.
                        "queryType": "str",  # Optional. A value that specifies the syntax of
                          the search query. The default is 'simple'. Use 'full' if your query uses the
                          Lucene query syntax. Known values are: "simple", "full", and "semantic".
                        "scoringParameters": [
                            "str"  # Optional. The list of parameter values to be used in
                              scoring functions (for example, referencePointParameter) using the format
                              name-values. For example, if the scoring profile defines a function with
                              a parameter called 'mylocation' the parameter string would be
                              "mylocation--122.2,44.8" (without the quotes).
                        ],
                        "scoringProfile": "str",  # Optional. The name of a scoring profile
                          to evaluate match scores for matching documents in order to sort the results.
                        "scoringStatistics": "str",  # Optional. A value that specifies
                          whether we want to calculate scoring statistics (such as document frequency)
                          globally for more consistent scoring, or locally, for lower latency. The
                          default is 'local'. Use 'global' to aggregate scoring statistics globally
                          before scoring. Using global scoring statistics can increase latency of
                          search queries. Known values are: "local" and "global".
                        "search": "str",  # Optional. A full-text search query expression;
                          Use "*" or omit this parameter to match all documents.
                        "searchFields": "str",  # Optional. The comma-separated list of field
                          names to which to scope the full-text search. When using fielded search
                          (fieldName:searchExpression) in a full Lucene query, the field names of each
                          fielded search expression take precedence over any field names listed in this
                          parameter.
                        "searchMode": "str",  # Optional. A value that specifies whether any
                          or all of the search terms must be matched in order to count the document as
                          a match. Known values are: "any" and "all".
                        "select": "str",  # Optional. The comma-separated list of fields to
                          retrieve. If unspecified, all fields marked as retrievable in the schema are
                          included.
                        "semanticConfiguration": "str",  # Optional. The name of a semantic
                          configuration that will be used when processing documents for queries of type
                          semantic.
                        "semanticErrorHandling": "str",  # Optional. Allows the user to
                          choose whether a semantic call should fail completely (default / current
                          behavior), or to return partial results. Known values are: "partial" and
                          "fail".
                        "semanticMaxWaitInMilliseconds": 0,  # Optional. Allows the user to
                          set an upper bound on the amount of time it takes for semantic enrichment to
                          finish processing before the request fails.
                        "semanticQuery": "str",  # Optional. Allows setting a separate search
                          query that will be solely used for semantic reranking, semantic captions and
                          semantic answers. Is useful for scenarios where there is a need to use
                          different queries between the base retrieval and ranking phase, and the L2
                          semantic phase.
                        "sessionId": "str",  # Optional. A value to be used to create a
                          sticky session, which can help getting more consistent results. As long as
                          the same sessionId is used, a best-effort attempt will be made to target the
                          same replica set. Be wary that reusing the same sessionID values repeatedly
                          can interfere with the load balancing of the requests across replicas and
                          adversely affect the performance of the search service. The value used as
                          sessionId cannot start with a '_' character.
                        "skip": 0,  # Optional. The number of search results to skip. This
                          value cannot be greater than 100,000. If you need to scan documents in
                          sequence, but cannot use skip due to this limitation, consider using orderby
                          on a totally-ordered key and filter with a range query instead.
                        "top": 0,  # Optional. The number of search results to retrieve. This
                          can be used in conjunction with $skip to implement client-side paging of
                          search results. If results are truncated due to server-side paging, the
                          response will include a continuation token that can be used to issue another
                          Search request for the next page of results.
                        "vectorFilterMode": "str",  # Optional. Determines whether or not
                          filters are applied before or after the vector search is performed. Default
                          is 'preFilter' for new indexes. Known values are: "postFilter" and
                          "preFilter".
                        "vectorQueries": [
                            vector_query
                        ]
                    },
                    "@search.semanticPartialResponseReason": "str",  # Optional. Reason that a
                      partial response was returned for a semantic ranking request. Known values are:
                      "maxWaitExceeded", "capacityOverloaded", and "transient".
                    "@search.semanticPartialResponseType": "str"  # Optional. Type of partial
                      response that was returned for a semantic ranking request. Known values are:
                      "baseResults" and "rerankedResults".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchDocumentsResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(search_request, (IOBase, bytes)):
            _content = search_request
        else:
            _content = json.dumps(search_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_documents_operations_search_post_request(
            index_name=index_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchDocumentsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get(  # pylint: disable=inconsistent-return-statements
        self, index_name: str, key: str, *, selected_fields: Optional[List[str]] = None, **kwargs: Any
    ) -> None:
        """Retrieves a document from the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param key: The key of the document to retrieve. Required.
        :type key: str
        :keyword selected_fields: List of field names to retrieve for the document; Any field not
         retrieved will
         be missing from the returned document. Default value is None.
        :paramtype selected_fields: list[str]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_documents_operations_get_request(
            index_name=index_name,
            key=key,
            selected_fields=selected_fields,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def suggest_get(
        self,
        index_name: str,
        *,
        search_text: str,
        suggester_name: str,
        _filter: Optional[str] = None,
        use_fuzzy_matching: Optional[bool] = None,
        highlight_post_tag: Optional[str] = None,
        highlight_pre_tag: Optional[str] = None,
        minimum_coverage: Optional[float] = None,
        order_by: Optional[List[str]] = None,
        search_fields: Optional[List[str]] = None,
        _select: Optional[List[str]] = None,
        _top: Optional[int] = None,
        **kwargs: Any
    ) -> _models.SuggestDocumentsResult:
        # pylint: disable=line-too-long
        """Suggests documents in the index that match the given partial query text.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :keyword search_text: The search text to use to suggest documents. Must be at least 1
         character, and
         no more than 100 characters. Required.
        :paramtype search_text: str
        :keyword suggester_name: The name of the suggester as specified in the suggesters collection
         that's part
         of the index definition. Required.
        :paramtype suggester_name: str
        :keyword _filter: An OData expression that filters the documents considered for suggestions.
         Default value is None.
        :paramtype _filter: str
        :keyword use_fuzzy_matching: A value indicating whether to use fuzzy matching for the
         suggestions query.
         Default is false. When set to true, the query will find terms even if there's a
         substituted or missing character in the search text. While this provides a
         better experience in some scenarios, it comes at a performance cost as fuzzy
         suggestions queries are slower and consume more resources. Default value is None.
        :paramtype use_fuzzy_matching: bool
        :keyword highlight_post_tag: A string tag that is appended to hit highlights. Must be set with
         highlightPreTag. If omitted, hit highlighting of suggestions is disabled. Default value is
         None.
        :paramtype highlight_post_tag: str
        :keyword highlight_pre_tag: A string tag that is prepended to hit highlights. Must be set with
         highlightPostTag. If omitted, hit highlighting of suggestions is disabled. Default value is
         None.
        :paramtype highlight_pre_tag: str
        :keyword minimum_coverage: A number between 0 and 100 indicating the percentage of the index
         that must be
         covered by a suggestions query in order for the query to be reported as a
         success. This parameter can be useful for ensuring search availability even for
         services with only one replica. The default is 80. Default value is None.
        :paramtype minimum_coverage: float
        :keyword order_by: The list of OData $orderby expressions by which to sort the results. Each
         expression can be either a field name or a call to either the geo.distance() or
         the search.score() functions. Each expression can be followed by asc to
         indicate ascending, or desc to indicate descending. The default is ascending
         order. Ties will be broken by the match scores of documents. If no $orderby is
         specified, the default sort order is descending by document match score. There
         can be at most 32 $orderby clauses. Default value is None.
        :paramtype order_by: list[str]
        :keyword search_fields: The list of field names to search for the specified search text. Target
         fields
         must be included in the specified suggester. Default value is None.
        :paramtype search_fields: list[str]
        :keyword _select: The list of fields to retrieve. If unspecified, only the key field will be
         included in the results. Default value is None.
        :paramtype _select: list[str]
        :keyword _top: The number of suggestions to retrieve. The value must be a number between 1 and


         #. The default is 5. Default value is None.
        :paramtype _top: int
        :return: SuggestDocumentsResult. The SuggestDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SuggestDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.text": "str"  # The text of the suggestion result.
                              Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was included in the query, or null if minimumCoverage was not set in
                      the request.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SuggestDocumentsResult] = kwargs.pop("cls", None)

        _request = build_documents_operations_suggest_get_request(
            index_name=index_name,
            search_text=search_text,
            suggester_name=suggester_name,
            _filter=_filter,
            use_fuzzy_matching=use_fuzzy_matching,
            highlight_post_tag=highlight_post_tag,
            highlight_pre_tag=highlight_pre_tag,
            minimum_coverage=minimum_coverage,
            order_by=order_by,
            search_fields=search_fields,
            _select=_select,
            _top=_top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SuggestDocumentsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def suggest_post(
        self,
        index_name: str,
        suggest_request: _models.SuggestRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SuggestDocumentsResult:
        # pylint: disable=line-too-long
        """Suggests documents in the index that match the given partial query text.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param suggest_request: The Suggest request. Required.
        :type suggest_request: ~azure.search.documents.models.SuggestRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SuggestDocumentsResult. The SuggestDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SuggestDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                suggest_request = {
                    "search": "str",  # The search text to use to suggest documents. Must be at
                      least 1 character, and no more than 100 characters. Required.
                    "suggesterName": "str",  # The name of the suggester as specified in the
                      suggesters collection that's part of the index definition. Required.
                    "filter": "str",  # Optional. An OData expression that filters the documents
                      considered for suggestions.
                    "fuzzy": bool,  # Optional. A value indicating whether to use fuzzy matching
                      for the suggestion query. Default is false. When set to true, the query will find
                      suggestions even if there's a substituted or missing character in the search
                      text. While this provides a better experience in some scenarios, it comes at a
                      performance cost as fuzzy suggestion searches are slower and consume more
                      resources.
                    "highlightPostTag": "str",  # Optional. A string tag that is appended to hit
                      highlights. Must be set with highlightPreTag. If omitted, hit highlighting of
                      suggestions is disabled.
                    "highlightPreTag": "str",  # Optional. A string tag that is prepended to hit
                      highlights. Must be set with highlightPostTag. If omitted, hit highlighting of
                      suggestions is disabled.
                    "minimumCoverage": 0.0,  # Optional. A number between 0 and 100 indicating
                      the percentage of the index that must be covered by a suggestion query in order
                      for the query to be reported as a success. This parameter can be useful for
                      ensuring search availability even for services with only one replica. The default
                      is 80.
                    "orderby": "str",  # Optional. The comma-separated list of OData $orderby
                      expressions by which to sort the results. Each expression can be either a field
                      name or a call to either the geo.distance() or the search.score() functions. Each
                      expression can be followed by asc to indicate ascending, or desc to indicate
                      descending. The default is ascending order. Ties will be broken by the match
                      scores of documents. If no $orderby is specified, the default sort order is
                      descending by document match score. There can be at most 32 $orderby clauses.
                    "searchFields": "str",  # Optional. The comma-separated list of field names
                      to search for the specified search text. Target fields must be included in the
                      specified suggester.
                    "select": "str",  # Optional. The comma-separated list of fields to retrieve.
                      If unspecified, only the key field will be included in the results.
                    "top": 0  # Optional. The number of suggestions to retrieve. This must be a
                      value between 1 and 100. The default is 5.
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.text": "str"  # The text of the suggestion result.
                              Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was included in the query, or null if minimumCoverage was not set in
                      the request.
                }
        """

    @overload
    async def suggest_post(
        self, index_name: str, suggest_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SuggestDocumentsResult:
        # pylint: disable=line-too-long
        """Suggests documents in the index that match the given partial query text.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param suggest_request: The Suggest request. Required.
        :type suggest_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SuggestDocumentsResult. The SuggestDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SuggestDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.text": "str"  # The text of the suggestion result.
                              Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was included in the query, or null if minimumCoverage was not set in
                      the request.
                }
        """

    @overload
    async def suggest_post(
        self, index_name: str, suggest_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SuggestDocumentsResult:
        # pylint: disable=line-too-long
        """Suggests documents in the index that match the given partial query text.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param suggest_request: The Suggest request. Required.
        :type suggest_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SuggestDocumentsResult. The SuggestDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SuggestDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.text": "str"  # The text of the suggestion result.
                              Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was included in the query, or null if minimumCoverage was not set in
                      the request.
                }
        """

    @distributed_trace_async
    async def suggest_post(
        self, index_name: str, suggest_request: Union[_models.SuggestRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SuggestDocumentsResult:
        # pylint: disable=line-too-long
        """Suggests documents in the index that match the given partial query text.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param suggest_request: The Suggest request. Is one of the following types: SuggestRequest,
         JSON, IO[bytes] Required.
        :type suggest_request: ~azure.search.documents.models.SuggestRequest or JSON or IO[bytes]
        :return: SuggestDocumentsResult. The SuggestDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SuggestDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                suggest_request = {
                    "search": "str",  # The search text to use to suggest documents. Must be at
                      least 1 character, and no more than 100 characters. Required.
                    "suggesterName": "str",  # The name of the suggester as specified in the
                      suggesters collection that's part of the index definition. Required.
                    "filter": "str",  # Optional. An OData expression that filters the documents
                      considered for suggestions.
                    "fuzzy": bool,  # Optional. A value indicating whether to use fuzzy matching
                      for the suggestion query. Default is false. When set to true, the query will find
                      suggestions even if there's a substituted or missing character in the search
                      text. While this provides a better experience in some scenarios, it comes at a
                      performance cost as fuzzy suggestion searches are slower and consume more
                      resources.
                    "highlightPostTag": "str",  # Optional. A string tag that is appended to hit
                      highlights. Must be set with highlightPreTag. If omitted, hit highlighting of
                      suggestions is disabled.
                    "highlightPreTag": "str",  # Optional. A string tag that is prepended to hit
                      highlights. Must be set with highlightPostTag. If omitted, hit highlighting of
                      suggestions is disabled.
                    "minimumCoverage": 0.0,  # Optional. A number between 0 and 100 indicating
                      the percentage of the index that must be covered by a suggestion query in order
                      for the query to be reported as a success. This parameter can be useful for
                      ensuring search availability even for services with only one replica. The default
                      is 80.
                    "orderby": "str",  # Optional. The comma-separated list of OData $orderby
                      expressions by which to sort the results. Each expression can be either a field
                      name or a call to either the geo.distance() or the search.score() functions. Each
                      expression can be followed by asc to indicate ascending, or desc to indicate
                      descending. The default is ascending order. Ties will be broken by the match
                      scores of documents. If no $orderby is specified, the default sort order is
                      descending by document match score. There can be at most 32 $orderby clauses.
                    "searchFields": "str",  # Optional. The comma-separated list of field names
                      to search for the specified search text. Target fields must be included in the
                      specified suggester.
                    "select": "str",  # Optional. The comma-separated list of fields to retrieve.
                      If unspecified, only the key field will be included in the results.
                    "top": 0  # Optional. The number of suggestions to retrieve. This must be a
                      value between 1 and 100. The default is 5.
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.text": "str"  # The text of the suggestion result.
                              Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was included in the query, or null if minimumCoverage was not set in
                      the request.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SuggestDocumentsResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(suggest_request, (IOBase, bytes)):
            _content = suggest_request
        else:
            _content = json.dumps(suggest_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_documents_operations_suggest_post_request(
            index_name=index_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SuggestDocumentsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def index(
        self, index_name: str, batch: _models.IndexBatch, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IndexDocumentsResult:
        # pylint: disable=line-too-long
        """Sends a batch of document write actions to the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param batch: The batch of index actions. Required.
        :type batch: ~azure.search.documents.models.IndexBatch
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IndexDocumentsResult. The IndexDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.IndexDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                batch = {
                    "value": [
                        {
                            "@search.action": "str"  # Optional. The operation to perform
                              on a document in an indexing batch. Known values are: "upload", "merge",
                              "mergeOrUpload", and "delete".
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "key": "str",  # The key of a document that was in the
                              indexing request. Required.
                            "status": bool,  # A value indicating whether the indexing
                              operation succeeded for the document identified by the key. Required.
                            "statusCode": 0,  # The status code of the indexing
                              operation. Possible values include: 200 for a successful update or
                              delete, 201 for successful document creation, 400 for a malformed input
                              document, 404 for document not found, 409 for a version conflict, 422
                              when the index is temporarily unavailable, or 503 for when the service is
                              too busy. Required.
                            "errorMessage": "str"  # Optional. The error message
                              explaining why the indexing operation failed for the document identified
                              by the key; null if indexing succeeded.
                        }
                    ]
                }
        """

    @overload
    async def index(
        self, index_name: str, batch: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IndexDocumentsResult:
        # pylint: disable=line-too-long
        """Sends a batch of document write actions to the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param batch: The batch of index actions. Required.
        :type batch: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IndexDocumentsResult. The IndexDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.IndexDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "key": "str",  # The key of a document that was in the
                              indexing request. Required.
                            "status": bool,  # A value indicating whether the indexing
                              operation succeeded for the document identified by the key. Required.
                            "statusCode": 0,  # The status code of the indexing
                              operation. Possible values include: 200 for a successful update or
                              delete, 201 for successful document creation, 400 for a malformed input
                              document, 404 for document not found, 409 for a version conflict, 422
                              when the index is temporarily unavailable, or 503 for when the service is
                              too busy. Required.
                            "errorMessage": "str"  # Optional. The error message
                              explaining why the indexing operation failed for the document identified
                              by the key; null if indexing succeeded.
                        }
                    ]
                }
        """

    @overload
    async def index(
        self, index_name: str, batch: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IndexDocumentsResult:
        # pylint: disable=line-too-long
        """Sends a batch of document write actions to the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param batch: The batch of index actions. Required.
        :type batch: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IndexDocumentsResult. The IndexDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.IndexDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "key": "str",  # The key of a document that was in the
                              indexing request. Required.
                            "status": bool,  # A value indicating whether the indexing
                              operation succeeded for the document identified by the key. Required.
                            "statusCode": 0,  # The status code of the indexing
                              operation. Possible values include: 200 for a successful update or
                              delete, 201 for successful document creation, 400 for a malformed input
                              document, 404 for document not found, 409 for a version conflict, 422
                              when the index is temporarily unavailable, or 503 for when the service is
                              too busy. Required.
                            "errorMessage": "str"  # Optional. The error message
                              explaining why the indexing operation failed for the document identified
                              by the key; null if indexing succeeded.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def index(
        self, index_name: str, batch: Union[_models.IndexBatch, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.IndexDocumentsResult:
        # pylint: disable=line-too-long
        """Sends a batch of document write actions to the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param batch: The batch of index actions. Is one of the following types: IndexBatch, JSON,
         IO[bytes] Required.
        :type batch: ~azure.search.documents.models.IndexBatch or JSON or IO[bytes]
        :return: IndexDocumentsResult. The IndexDocumentsResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.IndexDocumentsResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                batch = {
                    "value": [
                        {
                            "@search.action": "str"  # Optional. The operation to perform
                              on a document in an indexing batch. Known values are: "upload", "merge",
                              "mergeOrUpload", and "delete".
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "key": "str",  # The key of a document that was in the
                              indexing request. Required.
                            "status": bool,  # A value indicating whether the indexing
                              operation succeeded for the document identified by the key. Required.
                            "statusCode": 0,  # The status code of the indexing
                              operation. Possible values include: 200 for a successful update or
                              delete, 201 for successful document creation, 400 for a malformed input
                              document, 404 for document not found, 409 for a version conflict, 422
                              when the index is temporarily unavailable, or 503 for when the service is
                              too busy. Required.
                            "errorMessage": "str"  # Optional. The error message
                              explaining why the indexing operation failed for the document identified
                              by the key; null if indexing succeeded.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IndexDocumentsResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(batch, (IOBase, bytes)):
            _content = batch
        else:
            _content = json.dumps(batch, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_documents_operations_index_request(
            index_name=index_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IndexDocumentsResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def autocomplete_get(
        self,
        index_name: str,
        *,
        search_text: str,
        suggester_name: str,
        autocomplete_mode: Optional[Union[str, _models.AutocompleteMode]] = None,
        _filter: Optional[str] = None,
        use_fuzzy_matching: Optional[bool] = None,
        highlight_post_tag: Optional[str] = None,
        highlight_pre_tag: Optional[str] = None,
        minimum_coverage: Optional[float] = None,
        search_fields: Optional[List[str]] = None,
        _top: Optional[int] = None,
        **kwargs: Any
    ) -> _models.AutocompleteResult:
        # pylint: disable=line-too-long
        """Autocompletes incomplete query terms based on input text and matching terms in
        the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :keyword search_text: The incomplete term which should be auto-completed. Required.
        :paramtype search_text: str
        :keyword suggester_name: The name of the suggester as specified in the suggesters collection
         that's part
         of the index definition. Required.
        :paramtype suggester_name: str
        :keyword autocomplete_mode: Specifies the mode for Autocomplete. The default is 'oneTerm'. Use
         'twoTerms'
         to get shingles and 'oneTermWithContext' to use the current context while
         producing auto-completed terms. Known values are: "oneTerm", "twoTerms", and
         "oneTermWithContext". Default value is None.
        :paramtype autocomplete_mode: str or ~azure.search.documents.models.AutocompleteMode
        :keyword _filter: An OData expression that filters the documents used to produce completed
         terms
         for the Autocomplete result. Default value is None.
        :paramtype _filter: str
        :keyword use_fuzzy_matching: A value indicating whether to use fuzzy matching for the
         autocomplete query.
         Default is false. When set to true, the query will find terms even if there's a
         substituted or missing character in the search text. While this provides a
         better experience in some scenarios, it comes at a performance cost as fuzzy
         autocomplete queries are slower and consume more resources. Default value is None.
        :paramtype use_fuzzy_matching: bool
        :keyword highlight_post_tag: A string tag that is appended to hit highlights. Must be set with
         highlightPreTag. If omitted, hit highlighting is disabled. Default value is None.
        :paramtype highlight_post_tag: str
        :keyword highlight_pre_tag: A string tag that is prepended to hit highlights. Must be set with
         highlightPostTag. If omitted, hit highlighting is disabled. Default value is None.
        :paramtype highlight_pre_tag: str
        :keyword minimum_coverage: A number between 0 and 100 indicating the percentage of the index
         that must be
         covered by an autocomplete query in order for the query to be reported as a
         success. This parameter can be useful for ensuring search availability even for
         services with only one replica. The default is 80. Default value is None.
        :paramtype minimum_coverage: float
        :keyword search_fields: The list of field names to consider when querying for auto-completed
         terms.
         Target fields must be included in the specified suggester. Default value is None.
        :paramtype search_fields: list[str]
        :keyword _top: The number of auto-completed terms to retrieve. This must be a value between 1
         and 100. The default is 5. Default value is None.
        :paramtype _top: int
        :return: AutocompleteResult. The AutocompleteResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AutocompleteResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "queryPlusText": "str",  # The query along with the completed
                              term. Required.
                            "text": "str"  # The completed term. Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was considered by the autocomplete request, or null if minimumCoverage
                      was not specified in the request.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AutocompleteResult] = kwargs.pop("cls", None)

        _request = build_documents_operations_autocomplete_get_request(
            index_name=index_name,
            search_text=search_text,
            suggester_name=suggester_name,
            autocomplete_mode=autocomplete_mode,
            _filter=_filter,
            use_fuzzy_matching=use_fuzzy_matching,
            highlight_post_tag=highlight_post_tag,
            highlight_pre_tag=highlight_pre_tag,
            minimum_coverage=minimum_coverage,
            search_fields=search_fields,
            _top=_top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AutocompleteResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def autocomplete_post(
        self,
        index_name: str,
        autocomplete_request: _models.AutocompleteRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AutocompleteResult:
        # pylint: disable=line-too-long
        """Autocompletes incomplete query terms based on input text and matching terms in
        the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param autocomplete_request: The definition of the Autocomplete request. Required.
        :type autocomplete_request: ~azure.search.documents.models.AutocompleteRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AutocompleteResult. The AutocompleteResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AutocompleteResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                autocomplete_request = {
                    "search": "str",  # The search text on which to base autocomplete results.
                      Required.
                    "suggesterName": "str",  # The name of the suggester as specified in the
                      suggesters collection that's part of the index definition. Required.
                    "autocompleteMode": "str",  # Optional. Specifies the mode for Autocomplete.
                      The default is 'oneTerm'. Use 'twoTerms' to get shingles and 'oneTermWithContext'
                      to use the current context while producing auto-completed terms. Known values
                      are: "oneTerm", "twoTerms", and "oneTermWithContext".
                    "filter": "str",  # Optional. An OData expression that filters the documents
                      used to produce completed terms for the Autocomplete result.
                    "fuzzy": bool,  # Optional. A value indicating whether to use fuzzy matching
                      for the autocomplete query. Default is false. When set to true, the query will
                      autocomplete terms even if there's a substituted or missing character in the
                      search text. While this provides a better experience in some scenarios, it comes
                      at a performance cost as fuzzy autocomplete queries are slower and consume more
                      resources.
                    "highlightPostTag": "str",  # Optional. A string tag that is appended to hit
                      highlights. Must be set with highlightPreTag. If omitted, hit highlighting is
                      disabled.
                    "highlightPreTag": "str",  # Optional. A string tag that is prepended to hit
                      highlights. Must be set with highlightPostTag. If omitted, hit highlighting is
                      disabled.
                    "minimumCoverage": 0.0,  # Optional. A number between 0 and 100 indicating
                      the percentage of the index that must be covered by an autocomplete query in
                      order for the query to be reported as a success. This parameter can be useful for
                      ensuring search availability even for services with only one replica. The default
                      is 80.
                    "searchFields": "str",  # Optional. The comma-separated list of field names
                      to consider when querying for auto-completed terms. Target fields must be
                      included in the specified suggester.
                    "top": 0  # Optional. The number of auto-completed terms to retrieve. This
                      must be a value between 1 and 100. The default is 5.
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "queryPlusText": "str",  # The query along with the completed
                              term. Required.
                            "text": "str"  # The completed term. Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was considered by the autocomplete request, or null if minimumCoverage
                      was not specified in the request.
                }
        """

    @overload
    async def autocomplete_post(
        self, index_name: str, autocomplete_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AutocompleteResult:
        # pylint: disable=line-too-long
        """Autocompletes incomplete query terms based on input text and matching terms in
        the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param autocomplete_request: The definition of the Autocomplete request. Required.
        :type autocomplete_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AutocompleteResult. The AutocompleteResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AutocompleteResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "queryPlusText": "str",  # The query along with the completed
                              term. Required.
                            "text": "str"  # The completed term. Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was considered by the autocomplete request, or null if minimumCoverage
                      was not specified in the request.
                }
        """

    @overload
    async def autocomplete_post(
        self, index_name: str, autocomplete_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AutocompleteResult:
        # pylint: disable=line-too-long
        """Autocompletes incomplete query terms based on input text and matching terms in
        the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param autocomplete_request: The definition of the Autocomplete request. Required.
        :type autocomplete_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AutocompleteResult. The AutocompleteResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AutocompleteResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "queryPlusText": "str",  # The query along with the completed
                              term. Required.
                            "text": "str"  # The completed term. Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was considered by the autocomplete request, or null if minimumCoverage
                      was not specified in the request.
                }
        """

    @distributed_trace_async
    async def autocomplete_post(
        self, index_name: str, autocomplete_request: Union[_models.AutocompleteRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.AutocompleteResult:
        # pylint: disable=line-too-long
        """Autocompletes incomplete query terms based on input text and matching terms in
        the index.

        :param index_name: The name of the index. Required.
        :type index_name: str
        :param autocomplete_request: The definition of the Autocomplete request. Is one of the
         following types: AutocompleteRequest, JSON, IO[bytes] Required.
        :type autocomplete_request: ~azure.search.documents.models.AutocompleteRequest or JSON or
         IO[bytes]
        :return: AutocompleteResult. The AutocompleteResult is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.AutocompleteResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                autocomplete_request = {
                    "search": "str",  # The search text on which to base autocomplete results.
                      Required.
                    "suggesterName": "str",  # The name of the suggester as specified in the
                      suggesters collection that's part of the index definition. Required.
                    "autocompleteMode": "str",  # Optional. Specifies the mode for Autocomplete.
                      The default is 'oneTerm'. Use 'twoTerms' to get shingles and 'oneTermWithContext'
                      to use the current context while producing auto-completed terms. Known values
                      are: "oneTerm", "twoTerms", and "oneTermWithContext".
                    "filter": "str",  # Optional. An OData expression that filters the documents
                      used to produce completed terms for the Autocomplete result.
                    "fuzzy": bool,  # Optional. A value indicating whether to use fuzzy matching
                      for the autocomplete query. Default is false. When set to true, the query will
                      autocomplete terms even if there's a substituted or missing character in the
                      search text. While this provides a better experience in some scenarios, it comes
                      at a performance cost as fuzzy autocomplete queries are slower and consume more
                      resources.
                    "highlightPostTag": "str",  # Optional. A string tag that is appended to hit
                      highlights. Must be set with highlightPreTag. If omitted, hit highlighting is
                      disabled.
                    "highlightPreTag": "str",  # Optional. A string tag that is prepended to hit
                      highlights. Must be set with highlightPostTag. If omitted, hit highlighting is
                      disabled.
                    "minimumCoverage": 0.0,  # Optional. A number between 0 and 100 indicating
                      the percentage of the index that must be covered by an autocomplete query in
                      order for the query to be reported as a success. This parameter can be useful for
                      ensuring search availability even for services with only one replica. The default
                      is 80.
                    "searchFields": "str",  # Optional. The comma-separated list of field names
                      to consider when querying for auto-completed terms. Target fields must be
                      included in the specified suggester.
                    "top": 0  # Optional. The number of auto-completed terms to retrieve. This
                      must be a value between 1 and 100. The default is 5.
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "queryPlusText": "str",  # The query along with the completed
                              term. Required.
                            "text": "str"  # The completed term. Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was considered by the autocomplete request, or null if minimumCoverage
                      was not specified in the request.
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AutocompleteResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(autocomplete_request, (IOBase, bytes)):
            _content = autocomplete_request
        else:
            _content = json.dumps(autocomplete_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_documents_operations_autocomplete_post_request(
            index_name=index_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AutocompleteResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class SearchClientOperationsMixin(SearchClientMixinABC):

    @distributed_trace_async
    async def get_service_statistics(self, **kwargs: Any) -> _models.SearchServiceStatistics:
        # pylint: disable=line-too-long
        """Gets service level statistics for a search service.

        :return: SearchServiceStatistics. The SearchServiceStatistics is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchServiceStatistics
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "counters": {
                        "dataSourcesCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "documentCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "indexersCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "indexesCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "skillsetCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "storageSize": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "synonymMaps": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "vectorIndexSize": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        }
                    },
                    "limits": {
                        "maxComplexCollectionFieldsPerIndex": 0,  # Optional. The maximum
                          number of fields of type Collection(Edm.ComplexType) allowed in an index.
                        "maxComplexObjectsInCollectionsPerDocument": 0,  # Optional. The
                          maximum number of objects in complex collections allowed per document.
                        "maxFieldNestingDepthPerIndex": 0,  # Optional. The maximum depth
                          which you can nest sub-fields in an index, including the top-level complex
                          field. For example, a/b/c has a nesting depth of 3.
                        "maxFieldsPerIndex": 0,  # Optional. The maximum allowed fields per
                          index.
                        "maxStoragePerIndex": 0  # Optional. The maximum amount of storage in
                          bytes allowed per index.
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchServiceStatistics] = kwargs.pop("cls", None)

        _request = build_search_get_service_statistics_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchServiceStatistics, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
