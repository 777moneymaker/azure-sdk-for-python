# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
import sys
from typing import Any, Callable, Dict, IO, Optional, Type, TypeVar, Union, overload

from azure.core import MatchConditions
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceModifiedError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._model_base import SdkJSONEncoder, _deserialize
from ..._operations._operations import (
    build_search_index_data_sources_operations_create_or_update_request,
    build_search_service_data_sources_operations_delete_request,
)
from .._vendor import SearchIndexClientMixinABC, SearchServiceClientMixinABC

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class SearchIndexClientOperationsMixin(SearchIndexClientMixinABC):

    @overload
    async def data_sources_operations_create_or_update(
        self,
        data_source_name: str,
        data_source: _models.SearchIndexerDataSource,
        *,
        prefer: Union[str, _models.Enum0],
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource or updates a datasource if it already exists.

        :param data_source_name: The name of the datasource to create or update. Required.
        :type data_source_name: str
        :param data_source: The definition of the datasource to create or update. Required.
        :type data_source: ~azure.search.documents.models.SearchIndexerDataSource
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # JSON input template you can fill out and use as your body input.
                data_source = {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def data_sources_operations_create_or_update(
        self,
        data_source_name: str,
        data_source: JSON,
        *,
        prefer: Union[str, _models.Enum0],
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource or updates a datasource if it already exists.

        :param data_source_name: The name of the datasource to create or update. Required.
        :type data_source_name: str
        :param data_source: The definition of the datasource to create or update. Required.
        :type data_source: JSON
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @overload
    async def data_sources_operations_create_or_update(
        self,
        data_source_name: str,
        data_source: IO[bytes],
        *,
        prefer: Union[str, _models.Enum0],
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource or updates a datasource if it already exists.

        :param data_source_name: The name of the datasource to create or update. Required.
        :type data_source_name: str
        :param data_source: The definition of the datasource to create or update. Required.
        :type data_source: IO[bytes]
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """

    @distributed_trace_async
    async def data_sources_operations_create_or_update(
        self,
        data_source_name: str,
        data_source: Union[_models.SearchIndexerDataSource, JSON, IO[bytes]],
        *,
        prefer: Union[str, _models.Enum0],
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> _models.SearchIndexerDataSource:
        # pylint: disable=line-too-long
        """Creates a new datasource or updates a datasource if it already exists.

        :param data_source_name: The name of the datasource to create or update. Required.
        :type data_source_name: str
        :param data_source: The definition of the datasource to create or update. Is one of the
         following types: SearchIndexerDataSource, JSON, IO[bytes] Required.
        :type data_source: ~azure.search.documents.models.SearchIndexerDataSource or JSON or IO[bytes]
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str or ~azure.search.documents.models.Enum0
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: SearchIndexerDataSource. The SearchIndexerDataSource is compatible with MutableMapping
        :rtype: ~azure.search.documents.models.SearchIndexerDataSource
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # JSON input template you can fill out and use as your body input.
                data_source = {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ``<unchanged>`` (with brackets) if you don't want the
                          connection string updated. Set to ``<redacted>`` if you want to remove the
                          connection string value from the datasource.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          ``https://my-keyvault-name.vault.azure.net``. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        }
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchIndexerDataSource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(data_source, (IOBase, bytes)):
            _content = data_source
        else:
            _content = json.dumps(data_source, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_search_index_data_sources_operations_create_or_update_request(
            data_source_name=data_source_name,
            prefer=prefer,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchIndexerDataSource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class SearchServiceClientOperationsMixin(SearchServiceClientMixinABC):

    @distributed_trace_async
    async def data_sources_operations_delete(  # pylint: disable=inconsistent-return-statements
        self,
        data_source_name: str,
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a datasource.

        :param data_source_name: The name of the datasource to delete. Required.
        :type data_source_name: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_search_service_data_sources_operations_delete_request(
            data_source_name=data_source_name,
            etag=etag,
            match_condition=match_condition,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore
