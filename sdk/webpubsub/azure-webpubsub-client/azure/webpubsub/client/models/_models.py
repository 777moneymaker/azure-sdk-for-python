# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------


import sys
from typing import Any, Mapping, overload, Union, Optional

from .. import _model_base
from .._model_base import rest_discriminator, rest_field
from ._enums import DownstreamMessageType, UpstreamMessageType, WebPubSubDataType

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
if sys.version_info >= (3, 8):
    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
else:
    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object


class WebPubSubMessageBase:
    def __init__(self) -> None:
        self.kind = None


class AckMessageError:
    def __init__(self, name: str, message: str) -> None:
        self.name = name
        self.message = message


class AckMessage(WebPubSubMessageBase):
    def __init__(
        self, ack_id: int, success: bool, error: Optional[AckMessageError] = None
    ) -> None:
        super().__init__()
        self.kind: Literal["ack"] = "ack"
        self.ack_id = ack_id
        self.success = success
        self.error = error


class ConnectedMessage(WebPubSubMessageBase):
    def __init__(
        self, connection_id: int, user_id: str, reconnection_token: str
    ) -> None:
        super().__init__()
        self.kind: Literal["connected"] = "connected"
        self.connection_id = connection_id
        self.user_id = user_id
        self.reconnection_token = reconnection_token


class DisconnectedMessage(WebPubSubMessageBase):
    def __init__(self, message: str) -> None:
        super().__init__()
        self.kind: Literal["disconnected"] = "disconnected"
        self.message = message


class GroupDataMessage(WebPubSubMessageBase):
    def __init__(
        self,
        data_type: WebPubSubDataType,
        data: Any,
        group: str,
        from_user_id: str,
        sequence_id: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.kind: Literal["groupData"] = "groupData"
        self.data_type = data_type
        self.data = data
        self.group = group
        self.from_user_id = from_user_id
        self.sequence_id = sequence_id


class ServerDataMessage(WebPubSubMessageBase):
    def __init__(
        self, data_type: WebPubSubDataType, data: Any, sequence_id: Optional[int] = None
    ) -> None:
        super().__init__()
        self.kind: Literal["serverData"] = "serverData"
        self.data_type = data_type
        self.data = data
        self.sequence_id = sequence_id


class JoinGroupMessage(WebPubSubMessageBase):
    def __init__(
        self,
        group: str,
        ack_id: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.kind: Literal["joinGroup"] = "joinGroup"
        self.group = group
        self.ack_id = ack_id


class LeaveGroupMessage(WebPubSubMessageBase):
    def __init__(
        self,
        group: str,
        ack_id: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.kind: Literal["leaveGroup"] = "leaveGroup"
        self.group = group
        self.ack_id = ack_id


class SendEventMessage(WebPubSubMessageBase):
    def __init__(
        self,
        data_type: WebPubSubDataType,
        data: Any,
        event: str,
        ack_id: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.kind: Literal["sendEvent"] = "sendEvent"
        self.data_type = data_type
        self.data = data
        self.event = event
        self.ack_id = ack_id


class SendToGroupMessage(WebPubSubMessageBase):
    def __init__(
        self,
        data_type: WebPubSubDataType,
        data: Any,
        group: str,
        no_echo: bool,
        ack_id: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.kind: Literal["sendToGroup"] = "sendToGroup"
        self.data_type = data_type
        self.data = data
        self.group = group
        self.no_echo = no_echo
        self.ack_id = ack_id


class SequenceAckMessage(WebPubSubMessageBase):
    def __init__(self, sequence_id: int) -> None:
        super().__init__()
        self.kind: Literal["sequenceAck"] = "sequenceAck"
        self.sequence_id = sequence_id


def parse_payload(data: Any, data_type: str) -> Any:
    if data_type == "text":
        if not isinstance(data, str):
            raise TypeError("Message must be a string when dataType is text")
        return data
    if data_type == "json":
        return data
    if data_type == "binary" or data_type == "protobuf":
        # // TODO
        return data
    raise TypeError(f"Unsupported dataType: {data_type}")


class WebPubSubClientProtocolBase:
    def __init__(self) -> None:
        self.is_reliable_sub_protocol = None
        self.name = None

    @staticmethod
    def parse_messages(input: str) -> WebPubSubMessageBase:
        if input is None:
            raise Exception("No input")
        if not isinstance(input, str):
            raise Exception("Invalid input for JSON hub protocol. Expected a string.")

        message = json.loads(input)
        if message["type"] == "system":
            if message["event"] == "connected":
                result = ConnectedMessage(**message)
            elif message["event"] == "disconnected":
                result = DisconnectedMessage(**message)
            else:
                raise Exception()
        elif message["type"] == "message":
            if message["from"] == "group":
                data = parse_payload(message["data"], message["data_type"])
                result = GroupDataMessage(data=data, **message)
            elif message["type"] == "server":
                data = parse_payload(message["data"], message["data_type"])
                result = ServerDataMessage(data=data, **message)
            else:
                raise Exception()
        elif message["type"] == "ack":
            result = AckMessage(**message)
        else:
            raise Exception()
        return result

    @staticmethod
    def write_message(message: WebPubSubMessageBase) -> str:
        pass


class WebPubSubJsonProtocol(WebPubSubClientProtocolBase):
    def __init__(self) -> None:
        super().__init__()
        self.is_reliable_sub_protocol = False
        self.name = "json.webpubsub.azure.v1"


class WebPubSubJsonReliableProtocol(WebPubSubClientProtocolBase):
    def __init__(self) -> None:
        super().__init__()
        self.is_reliable_sub_protocol = True
        self.name = "json.reliable.webpubsub.azure.v1"

class WebPubSubRetryOptions:
    def __init__(
        self,
        max_retries: Optional[int] = None,
        retry_delay_in_ms: Optional[int] = None,
        max_retry_delay_in_ms: Optional[int] = None,
        mode: Optional[Literal["Exponential", "Fixed"]] = None,
    ) -> None:
        self.max_retries = max_retries
        self.retry_delay_in_ms = retry_delay_in_ms
        self.max_retry_delay_in_ms = max_retry_delay_in_ms
        self.mode = mode

class WebPubSubClientOptions:
    def __init__(
        self,
        protocol: Optional[WebPubSubClientProtocolBase] = None,
        auto_reconnect: Optional[bool] = None,
        auto_restore_groups: Optional[bool] = None,
        message_retry_options: Optional[WebPubSubRetryOptions] = None
    ) -> None:
        self.protocol = protocol
        self.auto_reconnect = auto_reconnect
        self.auto_restore_groups = auto_restore_groups
        self.message_retry_options = message_retry_options
