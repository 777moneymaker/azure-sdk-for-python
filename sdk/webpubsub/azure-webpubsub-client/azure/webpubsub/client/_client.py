# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from copy import deepcopy
from typing import Any, TYPE_CHECKING, overload, Callable, Union, Optional, Dict, TypeVar, Tuple
import sys
import math
import logging
from . import models
from .models import (
    WebPubSubClientState,
    WebPubSubClientOptions,
    WebPubSubRetryOptions,
    CallBackType,
    ConnectedMessage,
    WebPubSubJsonReliableProtocol,
)
import websocket
import threading
import time

_LOGGER = logging.getLogger(__name__)

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from azure.core.credentials import TokenCredential


class WebPubSubClientCredential:
    @overload
    def __init__(self, client_access_url_provider: str) -> None:
        ...

    @overload
    def __init__(self, client_access_url_provider: Callable[[Any], str]) -> None:
        ...

    def __init__(self, client_access_url_provider: Union[str, Callable[[Any], str]]) -> None:
        if isinstance(client_access_url_provider, str):
            self._client_access_url_provider = lambda: client_access_url_provider
        else:
            self._client_access_url_provider = client_access_url_provider

    def get_client_access_url(self) -> str:
        return self._client_access_url_provider()


class RetryPolicy:
    def __init__(self, retry_options: models.WebPubSubRetryOptions) -> None:
        self.retry_options = retry_options
        self.max_retries_to_get_max_delay = math.ceil(
            math.log2(self.retry_options.max_retry_delay_in_ms) - math.log2(self.retry_options.retry_delay_in_ms) + 1
        )

    def next_retry_delay_in_ms(self, retry_attempt: int) -> Union[int, None]:
        if retry_attempt > self.retry_options.max_retries:
            return None
        else:
            if self.retry_options.mode != "Fixed":
                return self.retry_options.retry_delay_in_ms
            else:
                return self.calculate_exponential_delay(retry_attempt)

    def calculate_exponential_delay(self, attempt: int) -> int:
        if attempt >= self.max_retries_to_get_max_delay:
            return self.retry_options.max_retry_delay_in_ms
        else:
            return (1 << (attempt - 1)) * self.retry_options.retry_delay_in_ms


class WebPubSubGroup:
    def __init__(self, name: str) -> None:
        self.name = name
        self.is_joined = False


class AckEntity:
    pass


class SequenceId:
    def __init__(self) -> None:
        self.sequence_id = 0
        self.is_update = False

    def try_update(self, sequence_id: int) -> bool:
        self.is_update = True
        if sequence_id > self.sequence_id:
            self.sequence_id = sequence_id
            return True
        return False

    def try_get_sequence_id(self) -> Tuple[bool, Union[int, None]]:
        if self.is_update:
            self.is_update = False
            return (True, self.sequence_id)
        return (False, None)

    def reset(self):
        self.sequence_id = 0
        self.is_update = False


class WebPubSubClient:  # pylint: disable=client-accepts-api-version-keyword
    """WebPubSubClient.

    :ivar health_api: HealthApiOperations operations
    :vartype health_api: azure.webpubsub.client.operations.HealthApiOperations
    :ivar web_pub_sub: WebPubSubOperations operations
    :vartype web_pub_sub: azure.webpubsub.client.operations.WebPubSubOperations
    :param endpoint: HTTP or HTTPS endpoint for the Web PubSub service instance. Required.
    :type endpoint: str
    :param credential: Credential needed for the client to connect to Azure. Required.
    :type credential: ~azure.core.credentials.TokenCredential
    :keyword api_version: Api Version. Default value is "2021-10-01". Note that overriding this
     default value may result in unsupported behavior.
    :paramtype api_version: str
    """

    @overload
    def __init__(
        self,
        credential: WebPubSubClientCredential,
        options: Optional[WebPubSubClientOptions] = None,
        **kwargs: Any,
    ) -> None:
        ...

    @overload
    def __init__(
        self,
        client_access_url: str,
        options: Optional[WebPubSubClientOptions] = None,
        **kwargs: Any,
    ) -> None:
        ...

    def __init__(
        self,
        credential: Optional[WebPubSubClientCredential] = None,
        client_access_url: Optional[str] = None,
        options: Optional[WebPubSubClientOptions] = None,
        **kwargs: Any,
    ) -> None:
        if credential:
            self._credential = credential
        elif client_access_url:
            self._credential = WebPubSubClientCredential(client_access_url)
        else:
            raise TypeError("Please input parameter credential or client_access_url")

        if options is None:
            options = WebPubSubClientOptions()
        self.build_default_options(options)
        self._options = options
        self._message_retry_policy = RetryPolicy(self._options.message_retry_options)
        self._reconnect_retry_policy = RetryPolicy(
            WebPubSubRetryOptions(max_retries=sys.maxint, retry_delay_in_ms=1000, mode="Fixed")
        )
        self._protocol = self._options.protocol
        self._group_map: Dict[str, WebPubSubGroup] = {}
        self._ack_map: Dict[int, models.SendMessageErrorOptions] = {}
        self._sequence_id = SequenceId()
        self._state = WebPubSubClientState.STOPPED
        self._ack_id = 0
        self._url = None
        self._ws = None
        self._handler = {CallBackType.CONNECTED: []}
        self._last_disconnected_message = None
        self._connection_id = None
        self._is_initial_connected = False
        self._is_stopping = False
        self._last_close_event = None
        self._reconnection_token = None

    def next_ack_id(self) -> int:
        self._ack_id = self._ack_id + 1
        return self._ack_id

    def send_message(self, message: models.WebPubSubMessage):
        pay_load = self._protocol.write_message(message)
        if self._ws is None or not self._ws.connected:
            raise Exception("The connection is not connected.")

        self.send(pay_load)

    def send_message_with_ack_id(
        self,
        message_provider: Callable[[int], models.WebPubSubMessage],
        ack_id: Optional[int] = None,
    ):
        if ack_id is None:
            ack_id = self.next_ack_id()

        message = message_provider(ack_id)
        if ack_id not in self._ack_map:
            self._ack_map[ack_id] = None
        try:
            self.send_message(message)
        except Exception as e:
            self._ack_map.pop(ack_id)
            raise e

        # wait for ack from service
        while True:
            self.switch_thread()
            if self._ack_map[ack_id]:
                options = self._ack_map.pop(ack_id)
                if options.error_detail is not None:
                    raise models.SendMessageError(message="Failed to send message.", options=options)
                break

    def get_or_add_group(self, name: str) -> models.WebPubSubGroup:
        if name not in self._group_map:
            self._group_map[name] = models.WebPubSubGroup(name=name)
        return self._group_map[name]

    def join_group(self, group_name: str):
        group = self.get_or_add_group(group_name)
        self.send_message_with_ack_id(
            message_provider=lambda id: models.JoinGroupMessage(group=group_name, ack_id=id),
        )
        group.is_joined = True

    def leave_group(self, group_name: str):
        group = self.get_or_add_group(group_name)
        self.send_message_with_ack_id(
            message_provider=lambda id: models.LeaveGroupMessage(group=group_name, ack_id=id),
        )
        group.is_joined = False

    def send_event(self, event_name: str, content: Any, data_type: models.WebPubSubDataType):
        self.send_message_with_ack_id(
            message_provider=lambda id: models.SendEventMessage(
                data_type=data_type, data=content, ack_id=id, event=event_name
            )
        )

    def send_to_group(self, group_name: str, content: Any, data_type: models.WebPubSubDataType):
        no_echo = False
        self.send_message_with_ack_id(
            message_provider=lambda id: models.SendToGroupMessage(
                group=group_name, data_type=data_type, data=content, ack_id=id, no_echo=no_echo
            )
        )

    @staticmethod
    def switch_thread():
        time.sleep(0.001)

    def on(self, type: str, listener: Callable[[Any], None]):
        self._handler[type].append(listener)

    def _call_back(self, type: CallBackType, *args):
        for func in self._handler[type]:
            if self._state == WebPubSubClientState.CONNECTED:
                func(args)

    def on_message(self, data: str):
        def handle_ack_message(message: models.AckMessage):
            if message.ack_id in self._ack_map:
                if message.success or (message.error and message.error.name == "Duplicate"):
                    self._ack_map[message.ack_id] = models.SendMessageErrorOptions()
                else:
                    self._ack_map[message.ack_id] = models.SendMessageErrorOptions(ack_id=message.ack_id, error_detail=message.error)

        def handle_connected_message(message: ConnectedMessage):
            self._connection_id = message.connection_id

            if not self._is_initial_connected:
                self._is_initial_connected = True

                connected_args = models.OnConnectedArgs(connection_id=message.connection_id, user_id=message.user_id)
                self._call_back("connected", connected_args)

        def handle_disconnected_message(message: models.DisconnectedMessage):
            self._last_disconnected_message = message

        parsed_message = self._protocol.parse_messages(data)
        type_handler = {
            "connected": handle_connected_message,
            "disconnected": handle_disconnected_message,
            "ack": handle_ack_message,
        }
        if parsed_message.kind in type_handler:
            type_handler[parsed_message.kind](parsed_message)
        else:
            raise Exception(f"unknown message type: {parsed_message.kind}")

    def _listen(self):
        while self._state == WebPubSubClientState.CONNECTED:
            try:
                op_code, frame = self._ws.recv_data_frame(True)
            except (
                websocket.WebSocketConnectionClosedException,
                websocket.KeyboardInterrupt,
            ) as e:
                if self._state == WebPubSubClientState.CONNECTED:
                    raise e
                pass
            else:
                if op_code == websocket.ABNF.OPCODE_TEXT or op_code == websocket.ABNF.OPCODE_BINARY:
                    data = frame.data
                    if op_code == websocket.ABNF.OPCODE_TEXT:
                        data = data.decode("utf-8")
                    self.on_message(data)

    def sequence_id_ack_periodically(self):
        while self._state == WebPubSubClientState.CONNECTED:
            try:
                is_updated, seq_id = self._sequence_id.try_get_sequence_id()
                if is_updated:
                    self.send_message(models.SequenceAckMessage(sequence_id=seq_id))
            finally:
                time.sleep(1)

    def connect(self):
        self._ws = websocket.WebSocket()
        self._ws.connect(self._url, subprotocols=[self._protocol.name])

        if self._is_stopping:
            try:
                self._ws.close()
            finally:
                return

        self._state = WebPubSubClientState.CONNECTED
        if self._protocol.is_reliable_sub_protocol:
            self._thread_seq_ack = threading.Thread(target=self.sequence_id_ack_periodically, daemon=True)
            self._thread_seq_ack.start()

        self._thread = threading.Thread(target=self._listen, daemon=True)
        self._thread.start()

    def start_core(self):
        self._state = models.WebPubSubClientState.CONNECTING
        _LOGGER.info("Staring a new connection")

        # Reset before a pure new connection
        self._sequence_id.reset()
        self._is_initial_connected = False
        self._last_close_event = None
        self._last_disconnected_message = None
        self._connection_id = None
        self._reconnection_token = None
        self._url = None

        self._url = self._credential.get_client_access_url()
        self.connect()

    def start(self):
        if self._is_stopping:
            _LOGGER.error("Can't start a client during stopping")
            return
        if self._state != models.WebPubSubClientState.STOPPED:
            _LOGGER.warn("Client can be only started when it's Stopped")
            return

        try:
            self.start_core()
        except Exception as e:
            self._state = models.WebPubSubClientState.STOPPED
            self._is_stopping = False
            raise e

    def stop(self):
        self._state = WebPubSubClientState.STOPPED
        self._ws.close()
        pass

    def send(self, message: str):
        self._ws.send(message)

    @staticmethod
    def build_default_options(self, options: WebPubSubClientOptions):
        if options.auto_reconnect is None:
            options.auto_reconnect = True
        if options.auto_restore_groups is None:
            options.auto_restore_groups = True
        if options.protocol is None:
            options.protocol = WebPubSubJsonReliableProtocol()

        self.build_message_retry_options(options)

    @staticmethod
    def build_message_retry_options(options: models.WebPubSubClientOptions):
        if options.message_retry_options is None:
            options.message_retry_options = models.WebPubSubRetryOptions()
        if options.message_retry_options.max_retries is None or options.message_retry_options.max_retries < 0:
            options.message_retry_options.max_retries = 3
        if (
            options.message_retry_options.retry_delay_in_ms is None
            or options.message_retry_options.retry_delay_in_ms < 0
        ):
            options.message_retry_options.retry_delay_in_ms = 1000
        if (
            options.message_retry_options.max_retry_delay_in_ms is None
            or options.message_retry_options.max_retry_delay_in_ms < 0
        ):
            options.message_retry_options.max_retry_delay_in_ms = 30000
        if options.message_retry_options.mode is None:
            options.message_retry_options.mode = "Fixed"
